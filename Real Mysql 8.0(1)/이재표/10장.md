# 10장 실행계획

MySQL의 실행계획을 이해해야 적절하게 튜닝이 가능하다. MySQL서버가 보여주는 실행계획에 가장 큰 영향을 미치는 정보와, 실행계획을 읽는 순서와 키워드, 알고리즘에 대해 살펴보자

## 10.1 통계정보

인덱스 정보만으로 실행계획을 수립했는데, 분포도에 대한 정보가 없어, 정확도가 떨어지는 경우가 많았다.

따라서 인덱스하지 않은 칼럼들에 대해 데이터 분포도를 수집해서 저장하는 히스토그램 정보가 도입됐다.

(그렇다고, 기존의 테이블이나 인덱스의 통계정보가 없어진것은 아니다.)

### 테이블 및 인덱스 통계 정보

비용기반 최적화에서 가장 중요한 것은 통계정보다.
>
> 예로들어, 1억건의 레코드가 저장된 테이블의 통계정보가 갱신되지 않아 레코드가 10건 미만인 것처럼 돼 있다면, 옵티마이저는 실제 쿼리를 실행할 때 인덱스 레인지 스캔이 아니라 테이블 풀스캔으로 실행해 버릴수 도
> 있어, 0.1초에 끝날 쿼리가 1시간이 걸릴수 있다.

MySQL서버에서는 실제 데이터를 일부 분석하여 통계정보를 보완해서 사용하여, 정확성을 높히기 시작했다.

#### MySQL 서버의 통계정보

기존의 MySQL의 통계정보는 휘발성이었다. 따라서 서버가 재가동되면 인덱스 레인지 스캔이 잘되다가, 갑자기 테이블 풀 스캔을 하는 경우가 발생할 수 있었다.

현재는 영구적인 저장이 가능해져, 이러한 문제가 줄어들었다.

#### 히스토그램

기존의 통계정보는 단순히 인덱스된 칼럼의 유니크값 개수정도만 가지고 있어서 실행 계획을 수립하기 부족했다.

현재는 데이터의 분포도를 참조할수 있는 히스토그램 정보를 활용할수 있게되었다.

##### 히스토그램 정보 수집 및 삭제

히스토그램은 2종류 타입이 지원된다.

- 싱글톤 히스토그램: 컬럼값 개별로 레코드 건수를 관리하는 히스토그램.Value-Based 히스토그램 또는 도수 분포라고도 불린다.
    - 유니크한 값의 개수가 상대적으로 적은경우 사용된다.
- 높이 균형 히스토그램: 칼럼값의 범위를 균등한 개수로 구분해서 관리하느 히스토그램으로, Height-Balanced 히스토그램라고도 불린다.

##### 히스토그램의 용도

히스토그램 정보가 없으면 옵티마이저는 단순히 인덱스의 개수로 통계를 내기 떄문에 균등하게 분포되어있다고 판단하곤한다.

하지만 실제 어떤 인덱스는 10건이, 어떤 인덱스는 1건만 있는 경우가 있기 때문에 히스토그램을 통해 실행계획을 만들어야한다.

### 코스트 모델

MySQL서버가 쿼리를 처리하려면 다음과 같은 다양한 작업을 필요로 한다.

- 디스크로부터 데이터 페이지 읽기
- 메모리로부터 데이터 페이지 읽기
- 인덱스 키 비교
- 레코드 평가
- 메모리 임시테이블 작업
- 디스크 임시테이블 작업

MySQL서버는 사용자의 쿼리에 대해 이러한 각 작업이 얼마나 필요한지 예측하고 전체비용을 계산한 결과를 바탕으로 최적의 실행 계획을 찾는다.

이렇게 전체 쿼리의 비용을 계산하는 데 필요한 단위 작업들의 비용을
코스트 모델이라한다.

즉, 작업들의 비율에 따라 실행계획수립이 달라질수 있다.

다음과 같이 단위작업의 코스트가 있다.

**Engine Cost**

| cost_name              | default_value | 설명             
|------------------------|---------------|----------------
| io_block_read_cost     | 1.00          | 디스크 데이터 페이지 읽기 
| memory_block_read_cost | 0.25          | 메모리 데이터 페이지 읽기 

**Server Cost**

| cost_name                    | default_value | 설명                 
|------------------------------|---------------|--------------------
| disk_temptable_create_cost   | 20.00         | 디스크 임시 테이블 생성      
| disk_temptable_row_cost      | 0.50          | 디스크 임시 테이블의 레코드 읽기 
| key_compare_cost             | 0.05          | 인덱스 키 비교           
| memory_temptable_create_cost | 1.00          | 메모리 임시 테이블 생성      
| memory_temptable_row_cost    | 0.10          | 메모리 임시 테이블의 레코드 읽기 
| row_evaluate_cost            | 0.10          | 레코드 비교             

각 단위작업의 비용을 모두 계산하는 것은 쉽지 않다. 중요한 점은 각 단위작업에 설정되는 비용값이 커지면 어떤 실행 계획들이 고비용으로 바뀌고, 어떤 실행계획들이 저비용으로 바뀌는지를 파악하는 것이다.

- key_compare_cost 비용을 높이면 MySQL 서버 옵티마이저가 가능하면 정렬을 수행하지 않는 방향의 실행 계획을 선택할 가능성이 높아진다.
- row_evaluate_cost 비용을 높이면 풀 스캔을 실행하는 쿼리들의 비용이 높아진다.
- MySQL 서버 옵티마이저는 가능하면 인덱스 레인지 스캔을 사용하는 실행 계획을 선택할 가능성이 높아진다.
- disk_temptable_create_cost 와 disk_temptable_row_cost 비용을 높이면 MySQL 옵티마이저는 디스크에 임시 테이블을 만들지 않는 방향의 실행 계획을 선택할 가능성이
  높아진다.
- io_block_read_cost 비용이 높아지면 MySQL 서버 옵티마이저는 가능하면 InnoDB 버퍼 풀에 데이터 페이지가 많이 적재돼 있는 인덱스를 사용하는 실행 계획을 선택할 가능성이 높아진다.
- memory_block_read_cost 비용이 높아지면 MySQL 서버 옵티마이저는 InnoDB 버퍼 풀에 적재된 데이터 페이지가 상대적으로 적다고 하더라도 그 인덱스를 사용할 가능성이 높아진다.

## 실행계획 확인

EXPLAIN을 통해 실행계획을 알수 있는데, 다양한 출력 포맷과 실행결과까지 확인하 수 있는 기능까지 있다.

## 실행 계획 분석

실행계획이 어떤 접근 방법을 사용해서 최적화를 수행하는지, 어떤인덱스를 사용하는지 이해하는것이 중요핟.

EXPLAIN명령의 결과표의 각 컬럼을 이해해보자

<img src="https://github.com/user-attachments/assets/5225c9e0-bb25-4d98-9ece-c669c4a1090e" width="500">

### ID컬럼

쿼리 안에 있는 select 키워드 단위로 구분하고, select 쿼리별로 부여되는 식별자 값이다.

- select문장은 하나인데, 여러 테이블이 조인되는 경우에는 id값이 증가하지 않고, 모두 같은 id가 부여된다.
- 모두 다른 select쿼리로 구성돼있으면, id값이 모두 다르다.

주의점: id값이 테이블의 접근 순서는 아니다.

순서를 테이블형태로 보기에는 어려움이 있어, `EXPLAIN FORMAT=TREE`명령으로 순서를 더 정확히 알수 있다

### SELECT_TYPE칼럼

각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 칼럼이다. 아래는 타입의 종류이다.

- SIMPLE
    - UNION이나 서브쿼리를 사용하지 않은 단순 SELECT 쿼리
    - JOIN이 포함되도 마찬가지이다.
    - 아무리 복잡해도 SIMPLE인 단위 쿼리는 하나만 존재한다.
- PRIMARY
    - UNION이나 서브쿼리를 가지는 SELECT 쿼리의 실행계획에서 가장 바깥쪽에 있는 단위 쿼리
    - PRIMARY인 단위 SELECT쿼리는 하나만 존재하며, 쿼리의 제일 바깥쪽에 있는 SELECT 단위 쿼리가 PRIMARY로 표시
- UNION
    - UNION으로 결합하는 단위 SELECT 쿼리 가운데 첫 번째 이후 쿼리의 select_type은 UNION으로 표시된다. 첫 번째 쿼리는 DERIVED로 표시된다. 왜냐하면 여러 쿼리의 결과를 합치기
      위한 임시 테이블이 필요하기 때문이다.
- DEPENTENT UNION
    - 이 경우도 UNION으로 결합하는 쿼리에서 표시되지만, 외부 쿼리의 영향을 받는 경우를 말한다.
- UNION RESULT
    - 결과를 버퍼링 하는 임시 테이블의 select_type이 UNION RESULT이다.
- SUBQUERY
    - FROM절 이외에서 사용되는 서브쿼리만을 의미한다.
    - FROM절에 사용된 서브쿼리는 DERIVED로 표시된다.
- DEPENTENT SUBQUERY
    - 서브쿼리가 바깥쪽에 정의된 컬럼을 사용하는 경우 표시된다.
- DERIVED
    - DERIVED는 단위 SELECT 쿼리의 결과로 메모리나 디스크에 임시 테이블을 생성하는 것을 의미한다.
- DEPENTENT DERIVED
    - LATERAL JOIN을 통해 FROM절 서브쿼리에서 외부 컬럼을 참조할 수 있는데, 이때 나오는 select_type이다.
- UNCACHEABLE SUBQUERY
    - 같은 서브쿼리가 여러번 실행될 때는 이전 실행 결과를 그대로 사용하도록 서브쿼리의 결과를 캐시한다.
    - 하지만 캐시를 사용하지 못하는 경우 select_type이 UNCACHEABLE SUBQUERY이다.
- UNCACHEABLE UNION
    - UNION + UNCACHEABLE
- MATERIALIZED
    - 주로 FROM절이나 IN(subquery) 형태의 쿼리에 사용된 서브쿼리의 최적화를 위해 사용된다.
    - 서브쿼리 내용을 임시 테이블로 구체화한 뒤 임시 테이블과 employees 테이블을 조인하는 형태로 최적화되어 처리된다.

### Table컬럼

MySQL서버의 실행계획은 단위select쿼리 기준이 아니라 테이블 기준으로 표시된다.

table컬럼에 `<>`로 둘러싸인 이름이 명시되는 경우가 많은데, 이는 해당 테이블이 임시테이블임을 의미한다. 또한 `<>`안의 숫자는 단위 select의 id이다.

| id | select_type | table       
|----|-------------|-------------
| 1  | PRIMARY     | <derived 2> 
| 1  | PRIMARY     | e           
| 2  | PRIMARY     | dept_emp    

첫번째 라인의 table칼럼의 값이 <derived2>인데, 이것은 단위 select쿼리의 id값이 2인 실행계획으로부터 만들어진 파생테이블을 가르킨다.

주어진 값으로 실행계획을 해석하면 다음과 같다.

1. 첫 번째 라인의 테이블이 <derived2>라는 것을 보아 이 라인보다 id값이 2인 라인이 먼저 실행되고 그 결과가 파생테이블로 준비돼야 한다는 것을 알 수 있다.
2. 세 번째 라인(id가 2)을 보면 select_type컬럼의 값이 DERIVED로 표시돼 있다. 즉, 이 라인은 table칼럼에 표시된 dept_emp를 읽어 파생테이블을 생성하는 것을 알 수 있다.
3. 세번째 라인의 분석이 끝났으므로 다시 실행계획의 첫번째 라인으로 돌아가자
4. 첫번째 라인과 두번째 라인은 같은 id값을 가지고 있는 것으로 봐서 2개 테이블(첫번째 라인의 <derived2>와 두번째 라인의 e테이블)이 조인되는 쿼리라는 사실을 알 수 있다. 그런데 <derived2>
   테이블이 e테이블보다 먼저 표시됐기 때문에 <derived2>가 드라이빙 테이블이 되고, e테이블이 드리븐 테이블이 된다.
   즉, <derived2>테이블을 먼저 읽고, e테이블로 조인을 실행했다는 것을 알 수 있다.

### Partitions칼럼

테이블을 파티셔닝하여 나눌수 있다. MySQL서버의 경우 통계적인 정보로 파티셔닝마다 어떻게 분포됐는지 모르지만, 조건에 파티셔닝의 조건에 따라 조회해야하는 파티셔닝 테이블을 나눈다.

재밌는것은 파티셔닝할때 풀테이블 스캔을 한다는 점이다. 물리적으로 파티셔닝되면 저장공간이 나뉘어 파티셔닝된 부분만 풀테이블 스캔하여 조회한다.

### type컬럼

type이후의 칼럼은 MySQL서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지를 나타낸다.(인덱스로 읽는지, 풀테이블스캔인지 등)

- System
  - 레코드가 1건이하로 존재하는 테이블을 참조하는 접근방식
  - InnoDB에서는 사용안됌
- const
  - 레코드의 건수와 관계없이 pk나 유니크 키를 사용하는 where절을 가지고 있음 
  - 반드시 1건을 반환하는 쿼리의 처리방식
  - 다중 pk나 유니크키를 쓸때 일부컬럼을 조건으로 조회할때는 1건이라 확신할수 없어 const사용불가
  - **무조건 1건**
- eq_ref
  - 여러테이블이 조인되는 쿼리에서 표시
  - 처음 읽은 테이블의 칼럼값을 다음에 읽어야하는 테이블의 pk나 유니크 키 칼럼의 검색조건에 사용할때 eq_ref를 사용한다.
  - 이전에 선행되는 테이블이 아닌 조인되는 테이블에 붙음
  - **첫번째는 아니어도, eq_ref가 붙는 드리븐 테이블은 무조건 1건**
- ref
  - 조인의 상관없이 사용된다.
  - 인덱스의 종류에 상관없이 동등조건으로 검색할 때 사용된다.
  - 1건이라는 보장이 없어 const나 eq_ref보다는 느리다.
  - 복합 인덱스일때 구성하는 컬럼중 하나로만 검색하는 경우가 대표적
  - **동등조건이지만 무조건 1건은 아님**
- fulltext
  - 전문검색 인덱스 사용
- ref_or_null
  - ref와 같은데, null비교가 추가된 형태
- unique_subquery
  - where조건절에 사용될 수 있는 IN형태의 쿼리를 위한 접근 방법이다.
  - 서브쿼리에서 중복되지 않는 유니크한 값만 반환할때 사용
  - ```SELECT * FROM DEPARTMENTS WHERE DEPT_NO IN (SELECT DEPT_NO FROM DEPT_EMP WHERE EMP_NO=10001)```
  - 서브쿼리가 NULL일수도?
  - 중복된 값이 없어서 중복제거를 진행하지 않는다.
- index_subquery
  - IN연산자의 특성상 IN(서브쿼리) 또는 IN(상수)형태의 조건은 괄호안에 있는 값의 목록에서 중복된 값을 먼저 제거해야한다
  - 만약 IN(서브쿼리)에서 중복된값을 반환할때, 인덱스를 이용해 중복을 없앨수 있을때 사용한다.
  - 중복값이 있을수도 있어서 중복제거작업을 진행한다.
- range
  - 인덱스 레인지 스캔 접근방법
- index_merge
  - 2개 이상의 인덱스를 이용해 각각의 검색 결과를 만든뒤, 그 결과를 병합해서 처리하는 방식
  - 여러 인덱스를 읽어야해서 일반적으로 range보다 효율성이 떨어짐
  - 전문 검색을 사용하는 쿼리에서 적용되지 않음
  - 항상 2개이상의 집합이 되기 때문에 두 집합의 교집합이나 합집합, 또는 중복제거와 같은 부가작업이 필요하다
- index
  - 이름때문에 index를 사용하니 빠르겠다라고 오해하지만, 인덱스 풀 스캔을 이용하여, range스캔과 같이 필요한 부분만 읽는것이 아니라 인덱스를 전부 읽는 방법이다.
- ALL
  - 유일하게 테이블 풀 스캔

위의 방식중 ALL을 제외하고 모두 인덱스를 사용하는 방법이다.

### possible_key칼럼
사용될뻔한 쿼리 목록. 딱히 큰 도움안됌. 무시ㄱ

### key컬럼
key는 실제로 실행계획에 사용되는 인덱스를 의미한다. 따라서 해당 값이 의도한 인덱스가 맞는지 잘 확인해야한다.

PRIMARY인 경우에는 pk를 썼다는것이고, 이외의 값은 테이블이나 인덱스를 생성할때 부여한 이름이다.

### key_len 칼럼
인덱스의 각 레코드에서 몇 바이트까지 사용했는지를 알려주는 값이다.

### ref칼럼
대부분의 경우 신경쓰지 않아도 무방한데, 가끔 `func`라고 표시될 때가 있다. 이는 참조용으로 사용되는 값을 그대로 사용한 것이 아닌 콜레이션 변환이나 값 자체의 연산을 거쳐서 참조됐다는 것을 의미한다.

### rows컬람
통계정보를 바탕으로 얼마나 많은 레코드가 포함되는지, 또는 각 인덱스 값의 분포가 어떤지 통계정보를 기준으로 조사하고 예측하는데, row칼럼은 효율성 판단을 위해 예측했던 레코드 건수를 보여준다.

해당 값에 따라 테이블 풀 스캔을 할수도, 인덱스를 이용할수도 실행계획이 바뀔수 있다.

### filtered컬럼
해당 컬럼은 퍼센트로 필터링 되고 남는 레코드의 비율을 나타낸다.

### extrea칼럼
성능과 관련된 내용을 표시한다. 내부 처리에 대해 깊이있는 내용을 보여준다.
