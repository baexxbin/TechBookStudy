# 9장 옵티마이저

## 9.1 개요

옵티마이저는 쿼리의 실행 계획을 수립하는 부분이다.

### 쿼리 실행 절차

쿼리가 실행되는 과정은 세 가지로 나눌 수 있다.

1. 사용자로부터 요청된 SQL 문장을 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 파싱한다.
2. SQL의 파싱 정보를 확인하면서, 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.

**1번 단계**  
해당 단계를 **SQL 파싱**이라 하며, MySQL 서버의 `SQL 파서` 모듈로 처리한다.  
만약 SQL 문법이 잘못됐다면 해당 단계에서 필터링하며, 쿼리 문장 자체가 아닌 `SQL 파스 트리`를 이용하여 쿼리를 실행한다.

**2번 단계**  
해당 단계를 **최적화 및 실행 계획 수립** 단계라 하며, 옵티마이저가 처리한다.  
1단계에서 만들어진 `SQL 파스트리`를 참조하여 다음 단계를 처리한다.

- 불필요한 조건 제거 및 복잡한 연산의 단순화
- 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
- 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스 결정
- 가져온 레코드들을 임시 테이블에 넣고 다시 가공해야 하는지 결정

해당 단계가 완료되면 **실행 계획**이 만들어지며, 수립된 계획대로 스토리지 엔진에서 레코드를 읽어온다.

### 옵티마이저 종류

옵티마이저는 **비용 기반 최적화** 방법과 **규칙 기반 최적화** 방법으로 나눌 수 있다.

---

> 최근 대부분의 DBMS는 비용 기반 최적화 방법을 채택한다.

---

**비용 기반 최적화**  
쿼리가 처리하기 위한 여러 가지 방법을 만들고, 각 작업의 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해 비용을 산출하여 최소 비용 방법으로 실행한다.

**규칙 기반 최적화**  
정해진 우선순위에 따라 실행 계획을 수립하는 방법이다.

## 기본 데이터 처리

### 풀테이블 스캔과 풀 인덱스 스캔

**풀테이블 스캔**  
풀테이블 스캔은 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어 요청된 작업을 처리하는 작업이다.

옵티마이저는 다음 조건이 일치할 때 주로 풀테이블 스캔을 선택한다.

- 테이블의 레코드가 너무 작아서 인덱스를 통해 읽는 것보다 풀테이블 스캔이 빠른 경우 (보통 테이블이 페이지 1개로 구성된 경우)
- WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
- 인덱스 레인지 스캔을 사용할 수 있는 쿼리라도 옵티마이저가 판단한 인덱스 조건 일치 레코드 건수가 너무 많은 경우

일반적으로 테이블의 전체 크기는 매우 크기 때문에 풀테이블 스캔은 큰 리소스를 필요로 한다.

> **리드 어헤드**  
> 어떤 영역의 데이터가 앞으로 필요할 것을 예측하고, 요청이 오기 전에 미리 디스크에서 읽어 InnoDB의 버퍼풀에 가져다 놓는 과정.

InnoDB는 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드 작업이 자동으로 실행된다.  
즉, 처음 몇 개의 데이터 페이지는 `포그라운드 스레드`가 페이지 읽기를 실행하지만, 이후에는 백그라운드 스레드에 읽기 작업을 넘긴다.

---

풀 인덱스 스캔도 같은 과정으로 실행된다.

```sql
SELECT COUNT(*)
FROM user;
-- 옵티마이저가 인덱스 풀 스캔을 실행. 어차피 개수만 세면 인덱스로 세는 것이 테이블 자체보다 용량이 작은 인덱스를 사용.

SELECT *
FROM user;
-- 레코드에만 있는 컬럼이 필요하기 때문에 풀테이블 스캔 사용.
```

### 병렬 처리

---

> 여러 쿼리를 각각 처리하는 용도의 병렬 처리가 아닌, 하나의 쿼리를 여러 스레드가 동시에 처리하는 것을 의미한다.

---

MySQL 8.0에서는 단순히 테이블의 전체 건수를 가져오는 쿼리만 병렬로 처리가 가능하다.

```sql
SET SESSION innodb_parallel_read_threads = (병렬 처리 스레드 개수);
SELECT COUNT(*)
FROM employee;
```

> **주의**  
> 스레드 개수가 CPU의 코어 개수를 초과하면 성능이 오히려 떨어질 수 있다.

### Order By 처리 (Using filesort)

대부분의 정렬은 조회 쿼리에 포함되어 있다.  
정렬을 처리하는 방법은 인덱스를 이용하는 방법과 쿼리가 실행될 때 `Filesort`라는 별도의 처리를 이용하는 방법이 있다.

| 정렬 방식           | 장점                                                    | 단점                                                            |
|-----------------|-------------------------------------------------------|---------------------------------------------------------------|
| **인덱스 이용**      | 이미 인덱스가 정렬되어 있으므로 Insert, Update, Delete 쿼리가 순서대로 처리됨 | 부가적인 인덱스 추가/삭제 작업이 필요하여 오버헤드 발생. 디스크 공간과 InnoDB 버퍼풀 메모리 과다 사용 |
| **Filesort 이용** | 정렬 레코드가 많지 않으면 메모리에서 Filesort 처리 가능                   | 쿼리 실행 시 처리되므로 레코드가 많아질수록 쿼리 응답 속도 저하                          |

가능하면 인덱스를 통해 조회하는 것이 좋지만, 모든 정렬을 인덱스로 처리하는 것은 어렵다. 예를 들어:

- 정렬 기준이 너무 많아 모두 인덱스를 생성하는 것이 불가한 경우
- GROUP BY의 결과 또는 DISTINCT 같은 처리의 **결과**를 정렬해야 하는 경우
- UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
- 랜덤하게 경과 레코드를 가져와야 하는 경우

MySQL의 정렬 특성을 이해하여 튜닝 시 더 빠른 쿼리를 만들어 보자.

---

**소트 버퍼**  
MySQL은 정렬을 수행하기 위해 별도의 메모리 공간을 할당받고 이를 **소트 버퍼**라고 한다.  
소트 버퍼보다 정렬해야 할 레코드가 클 경우, 정렬 후 디스크에 임시 저장한 뒤 병합하며 정렬을 수행한다. 이를 **멀티 머지**라 한다.

> 소트 버퍼 크기를 단순히 늘리는 것은 효과적이지 않을 수 있다.  
> 소트 버퍼는 세션 메모리 영역이므로 커넥션 수가 많으면 메모리 부족 현상이 발생할 수 있다.

**정렬 알고리즘**  
정렬 시 소트 버퍼에 담는 레코드에 따라 **싱글패스**와 **투패스** 정렬 모드로 나뉜다.


> **싱글패스 정렬 방식**  
> 소트 버퍼에 `정렬 기준 컬럼`과 `SELECT 대상 컬럼` 전부를 담아 정렬하는 방식.
>
> <img src="https://github.com/user-attachments/assets/12118cac-2f1c-4630-8d29-37d7c696e26d" width=300>
>
> 정렬에 필요하지 않은 칼럼까지 전부 읽어서 소트버퍼에 담고 정렬을 수행한다. 정렬이 완료되면 정렬 버퍼의 내용을 그대로 클라이언트에게 넘겨주는 과정을 볼 수 있다.
>
> **투 패스 정렬 방식**
>
> `정렬대상 칼럼`과 `PK`만 소트 버퍼에 담아 정렬을 수행하고, 정렬된 순서대로 다시 PK로 테이블을 읽어서 SELECT할 칼럼을 가져오는 정렬방식
>
> <img src="https://github.com/user-attachments/assets/2dd065c7-117a-46ef-a644-2b3fe5551738" width=300>
>
> ---
> `투패스방식`은 불필요하게 조회가 한번 더 필요하기 때문에 `싱글패스방식`이 대부분 사용된다.
>
> 따라서 조회할때 꼭 필요한 필드만을 가져오는 것이 아니라 모든 컬럼(*)을 가져오도록 하면 소트버퍼에 영향을 미쳐 성능이 몇배에서 몇십배까지 안좋아질수 있다.

**정렬 처리 방식**

Order By가 사용되면 다음 3가지 방법 중 하나로 정렬되고, 아래 표에서 일반적으로 아래로갈수록 느리다

| 정렬처리방법                     | 실행 계획의 Extra칼럼내용                          |
|----------------------------|-------------------------------------------|
| 인덱스를 사용한 정렬                | 별도 표기없음                                   |
| 조인에서 드라이빙 테이블만 정렬          | "Using filesort"메시지가 표시됨                  |
| 조인에서 조인 결과를 임시 테이블로 저장후 정렬 | "Using temporary; Using filesort"메시지가 표시됌 |

> **인덱스를 이용한 정렬**
>
> <img src="https://github.com/user-attachments/assets/f416207c-b841-4403-b93e-13dc5044e366" width=300>
>
> 다음과 같은 조건이 있어야한다.
>
> - 인덱스를 이용한 정렬을 위해서는 ORDER BY에 명시된 칼럼이 제일 먼저 읽는 테이블(조인이 사용된 경우 드라이빙 테이블)에 속하고, Order By의 순서대로 생성된 인덱스가 있어야한다.
>
> - Where절에 첫번째로 읽는 테이블의 칼럼에 대한 조건이 있다면, 그 조건과 Order By는 같은 인덱스를 사용할 수 있어야한다.

> **조인의 드라이빙 테이블만 정렬**
>
> <img src="https://github.com/user-attachments/assets/03948fef-46e5-4489-aec2-ad8387e1a269" width="300">
>
> 인덱스 이용이 불가하고, 결과 레코드의 건수가 늘어나면 첫번째 테이블의 레코드를 먼저 정렬한 다음 조인을 실행하는 것이 차선책이 될것이다.
>
> 해당 방법으로 정렬을 처리하려면 조인에서 첫번째로 읽히는 테이블(드라이빙 테이블)의 칼럼만으로 ORDER BY절을 작성해야한다.
>

> **임시테이블을 이용한 정렬**
>
> 드라이빙 테이블만 정렬하는 것의 조건은 ORDER BY에서 드라이빙 테이블의 컬럼을 조건으로 건다는 것이다.
>
> 하지만 드리븐 테이블의 컬럼을 ORDER BY의 조건으로 걸게되면 정렬 전에 드리븐 테이블의 레코드를 알아야하기 때문에 조인된 데이터를 가지고 정렬하게 된다.
>
> mYsql에서는 `임시 테이블`에 조인된 결과를 저장하고, 해당 결과를 다시 정렬하는 방식으로 쿼리를 실행한다.

### 정렬 처리 방법의 성능 비교

쿼리에서 인덱스를 사용하지 못하는 정렬이나 그루핑 작업이 느리게 작동할 수 밖에 없는 이유는 쿼리가 처리되는 방식에 있다. 쿼리가 처리되는 방법 2가지에 대해 알아보자

**스트리밍 방식**

- 조건에 일치하는 레코드가 검색될때마다 바로 클라이언트로 전송하는 방식
- 쿼리가 스트리밍 방식으로 처리될수 있다면, 클라이언트는 MySQL서버가 일치하는 레코드를 찾는 즉시 전달받기 때문에 동시에 데이터 가공작업을 시작할 수 있다.

**버퍼링 방식**

- Order By나 Group By같은 처리는 쿼리의 결과가 스트리밍되는것을 부가능하게 한다. 왜냐하면, Where조건에 일치하는 모든 레코드를 가져온후, 정렬하거나 그루핑해서 차례대로 보내야하기 때문이다.
- MySQL서버에서는 모든 레코드를 검색하고 정렬하는 동안 클라이언트는 아무것도 하지못하기 때문에 응답속도가 느려진다.

## Group By처리

Group By또한 Order By와 마찬가지로 쿼리가 스트리밍된 처리를 할 수 없게하는 처리중 하나이다.

Group By는 Having을 통해 필터링할 수 있는데, Group By에 사용된 조건은 인덱스를 통해 처리될수 없으므로, Having절 튜닝을 위해 인덱스를 생성할 필요 없다.

Group By도 인덱스를 사용하는 경우와 그렇지 못한 경우로 나눌수 있다.

### 인덱스 스캔을 이용하는 Group By

Order By와 마찬가지로 조인의 드라이빙 테이블에 속한 칼럼만 이용해 그루핑할 때 Group By칼럼으로 이미 인덱스가 있다면 해당 인덱스를 읽으면서 그루핑작업을 수행하고, 해당 결과로 조인을 처리한다.

### 루스 인덱스 스캔을 이용하는 Group By(인덱스를 건너뛰면서 읽는 방법)

루스 인덱스 스캔 방식은 인덱스의 레코드를 건너뛰면서 필요한 부분만 읽어 가져오는 것을 의미한다.

### 임시 테이블을 사용하는 GROUP BY

GROUP BY의 기준 칼럼이 드라이빙 테이블에 있든, 드리븐 테이블에 있든 관계없이 인덱스를 사용하지 못할때 해당 방식으로 처리된다.

## 9.3 고급 최적화

옵티마이저가 실행 계획을 수립할 때 통계정보와 옵티마이저 옵션을 결합해서 사용한다.

옵티마이저 옵션은 크게 조인과 관련된 옵션과, 옵티마이저 스위치로 구분할수 있다.

> 옵티마이저 스위치: 고급 최적화 기능 활성화 여부를 제어하는 용도

### 옵티마이저 스위치 옵션

옵티마이저 스위치 옵션은 `optimizer_switch`변수를 통해 제어한다. MySQL서버 전체와 커넥션을 다르게 설정이 가능하다. 고급 최적화의 구체적인 설명을 알아보자

<br><br>

**MRR과 배치 키 액세스**

MRR은 `Multi-Range Read`를 줄여서 부르는 이름이다.

지금까지 조인은 드라이빙 테이블의 레코드를 한건 읽고, 일치하는 드리븐 레코드를 찾아 조인을 수행했다.(네스티드 루프 -> 조인의 연결조건이 되는 컬럼이 인덱스인 경우)

MySQL서버의 구조상 조인처리는 MySQL엔진이, 실제 레코드를 검색하고 조회하는 것은 스토리지 엔진이 처리한다. 이때 드라이빙 테이블의 레코드 건별로 드리븐 테이블의 레코드를 찾으면 레코드를 찾고 읽는 스토리지
엔진에서는 최적화가 불가하다.

단점을 보완하기 위해 다음과 같은 방식을 지원한다.

1. 드라이빙 테이블의 레코드를 읽어 드리븐 테이블과 조인을 즉시 실행하는 것이 아닌, 조인 대상을 버퍼링한다.
2. 조인버퍼에 레코드가 가득차면 MySQL엔진은 버퍼링 된 레코드를 한번에 스토리지 엔진에 요청한다.
3. 요청된 조인버퍼의 레코드는 정렬이 되어, 스토리지 엔진 입장에서 디스크 데이터 페이지 접근을 최소화할수 있다.

<br><br>

**블록 네스티드 루프 조인**

네스티드 루프 조인은 마치 중첩반복문처럼 드라이빙 테이블와 조건에 맞는 드리븐 테이블을 모두 조인하고 다음 드라이빙 테이블을 또 조인하듯 진행된다.

이렇게하면, 드리븐 테이블의 경우 드라이빙 테이블을 한번 돌때마다 풀 스캔을 한다는 의미이다.(또는 인덱스)

그러면 성능이 너무 안좋기 때문에 드라이빙 테이블에서 읽은 레코드를 메모리에 캐시한 후 드리븐 테이블과 메모리 캐시를 조인하는 방식으로 처리한다.

그러면 드라이빙 테이블을 모두 돌면서 일치하는 드리븐 테이블을 찾는 것이 아닌, 드라이빙 테이블은 조인 버퍼에 올라가있으니, 드리븐 테이블이 조인버퍼에서 일치하는 것을 찾기때문에 기존에 M^N이었다면 N*M이 될수
있다.

> MySQL8.0부터는 해시 조인 알고리즘이 도입되어 더이상 사용하진 않는다... 아 이해하는데 오래걸렸는데..

<br>

**인덱스 컨디션 푸시다운**

MySQL엔진에서는 복합인덱스에서 인덱스 범위제한 조건으로 사용하지 못하는 인덱스는 스토리지 엔진에게 보내주지 않았다. 따라서 인덱스를 비교하는 작업을 하는 스토리지 엔진은 풀스캔을 할수밖에 없다.

예로들면 다음과 같은 상황이다.

```sql
select *
from employees
where last_name = 'Action'
  and first_name LIKE '%sal';

-- index는 (last_name, first_name)의 복합인덱스 
```

실행 계획은 다음과 같다.

| id | select_type | table     | type | key                   | extrea      |
|----|-------------|-----------|------|-----------------------|-------------|
| 1  | simple      | employees | ref  | ix_lastname_firstname | using where |

`using where`는 인덱스를 사용할 수 없어, where조건에 일치하는지 검사하는 과정을 의미한다. 해당 쿼리에서는 `first_name LIKE %sal` 조건이 해당된다.

이렇게하면 다음과 같다.

<img src="https://github.com/user-attachments/assets/345022b4-beba-4cac-a70c-896f6ff8907c" width="400">

인덱스를 통해 조회한후, 인덱스를 사용못하는 부분은 풀스캔을 하게된다. 그림에서는 2개의 데이터만 일치하지 않지만, 만약 10만개의 데이터에서 1개만 일치한다면? 너무 비효율적이다.

근데, 보면 인덱스에 해당하는 조건인데 인덱스에서 필터링하면 되지 않을까?

처음에 말한것처럼 인덱스를 비교하는 것은 스토리지 엔진인데, MySQL엔진에서 처리 안되는 인덱스는 보내주지 않았다.

이때 사용하는 것이 인덱스 컨디션 푸시다운으로, 이를 사용하면 인덱스에서 필터링하여 해당하는 조건의 값만 스캔하게 된다!

<br>
<br>

**인덱스 확장**

InnoDB는 세컨더리 인덱스의 리프노드에 PK가 논리적 주소로 저장되어 있다.

인덱스 확장은 세컨더리 인덱스에 자동으로 추가된 PK를 ㅗ할용할 수 있게 하는 옵션이다.

```sql
create table dept_emp
(
    emp_no    INT     NOT NULL,
    dept_no   CHAR(4) NOT NULL,
    from_Date DATE    NOT NULL,
    to_date   DATE    NOT NULL,
    PRIMARY KEY (dept_no, emp_no),
    KEY       ix_fromdate(from_date)
)ENGINE=InnoDB

```

세컨더리 인덱스 ix_fromdate를 사용하면 결국 리프노드에서 PK를 사용하니, 인덱스를 확장하여 (from_date,dept_no,emp_no) 조합으로 인덱스를 생성한 것과 흡사하게 작동할 수 있다.

<br>
<br>

**인덱스 머지**

대부분 옵테마이저는 테이블별로 하나의 인덱스만 사용하도록 실행계획을 수립한다.

인덱스 머지 실행계획을 사용하면, 하나의 테이블에 대해 2개 이상의 인덱스를 이용해 쿼리를 처리할수 있다.

1. 교집합

    - where조건에 사용된 조건이 각각의 인덱스를 가진 경우, 여러개의 인덱스를 각각 검색해서 결과의 교집합을 반환
    - 비효율적이라 생각되면 비활성화 가능


2. 합집합

    - 인덱스에 대한 조건이 OR로 연결되어 있을때 사용된다.
    - 사실 두개 이상의 인덱스가 존재한다면, 분리해서 조회하게된다.
    - `select * from employees where first_name='Matt' OR hire_date='1987-03-31'`은 OR을 기준으로 두개로 나뉘어 실행되고 합쳐진다 생각할수 있다.
    - 주의할점은 나눠 조회하면 중복된 데이터에 대해 2개이상의 데이터가 나올수 있다 생각하지만, 정렬 비교하여 중복을 삭제해준다.

<br>
<br>

**세미조인**

실제 조인은 하지 않고, 단지 다른 테이블에서 조건에 일치하는 레코드가 있는지 없는지만 체크하는 형태의 쿼리를 `세미 조인`이라고 한다.

```sql
SELECT *
FROM EMPLOYEES E
WHERE E.EMP_NO IN (SELECT DE.EMP_NO FROM DEPT_EMP DE WHERE DE.FROM_DATE = '1995-01-01');
```

다음과 같은 쿼리가 있으면, 보통 IN절에 있는 서브쿼리를 먼저 처리한 후, 메인 SELECT쿼리를 처리할것이라 생각할수 있다.

하지만 MySQL은 EMPLOYEES 테이블을 풀 스캔하면서, 각 레코드들이 서브쿼리에 일치하는지 비교한다. 따라서 실행계획은 다음과 같다.

| ID | SELECT_TYPE | TABLE | TYPE | KEY         | ROWS   |
|----|-------------|-------|------|-------------|--------|
| 1  | PRIMARY     | E     | ALL  | NULL        | 300363 |
| 2  | SUBQUERY    | DE    | REF  | IX_FROMDATE | 57     |

풀스캔후, 서브쿼리에 존재하는지 비교하기 때문에 세미조인이라 부를수있다.

실행계획을 확인하면, 서브쿼리로 비교한후, SELECT 하면 57건만 읽을수 있지만, 세미조인으로인해 300000건이 모두 읽히게 된다.

서브쿼리 최적화 중 세미조인 최적화방법으로는 아래와 같이 있다.

- Table Pull-out
- Duplicate Weed-out
- First Match
- Loose Scan
- Materialization

**Table Pull-out**

Table pullout최적화는 세미조인의 서브쿼리에 사용된 테이블을 아우터 쿼리로 끄집어 낸후 쿼리를 조인쿼리로 재작성하는 방법이다.

```sql
SELECT *
FROM EMPLOYEES E
WHERE E.EMP_NO IN (SELECT DE.EMP_NO FROM DEPT_EMP WHERE DE.DEPT_NO = 'D009');
```

다음과 같은 쿼리가 있을때 Tabel Pull-Out이 적용되면 쿼리는 다음과 같이 변한다.

```sql
 select `employees`.`e`.`emp_no`     AS `emp_no`
      , `employees`.`e`.`birth_date` AS `birth_date`
      , `employees`.`e`.`first_name` AS `first_name`
      , `employees`.`e`.`last_name`  AS `last_name`
      , `employees`.`e`.`gender`     AS `gender`
      , `employees`.`e`.`hire_date`  AS `hire_date`
 from `employees`.`dept_emp` `de`
          join `employees`.`employees` `e`
 where ((`employees`.`e`.`emp_no` = `employees`.`de`.`emp_no`)
     and (`employees`.`de`.`dept_no` = 'd009'))  
```

쿼리에서 보이듯, IN형태는 없어지고, Join으로 쿼리가 재작성되었다.

pull-out의 제약은 다음과 같다.

- 세미 조인 서브쿼리에서만 사용가능하다.
- 서브쿼리부분이 UNIQUE인덱스나 프라이머리 키 룩업(PK로 레코드를 찾는 것)으로 결과가 1건인 경우에만 사용가능

**퍼스트 매치**

퍼스트매치는 IN형태의 세미조인을 EXISTS형태로 튜닝한 것과 비슷한 방법으로 실행된다.

```sql
SELECT *
FROM EMPLOYEES E
WHERE E.FIRST_NAME = 'MATT'
  AND E.EMP_NO IN (SELECT T.EMP_NO FROM TITLES T WHERE T.FROM_DATE BETWEEN '1995-01-01' AND '1995-01-30');

```

실행계획은 다음과 같다.

| ID | SELECT_TYPE | TABLE | TYPE | POSSIBLE_KEY         | KEY          | KEY_LEN | REF                | ROWS | EXTRA                                   |
|----|-------------|-------|------|----------------------|--------------|---------|--------------------|------|-----------------------------------------|
| 1  | PRIMARY     | e     | ref  | PRIMARY,ix_firstname | ix_firstname | 44      | const              | 233  | Using index condition                   |
| 1  | PRIMARY     | t     | ref  | PRIMARY              | PRIMARY      | 4       | employees.e.emp_no | 1    | Using where; Using index; FirstMatch(e) |

실행계획을 보면 FirstMatch라는 문구가 출력됐다.

FirstMatch는 ID가 같은것을 보아 서브쿼리 패턴이 아닌 조인으로 처리됐다는 것을 알 수 있다.

FirstMatch는 employees테이블의 레코드에 대해 titles 테이블에 일치하는 레코드 1건만 찾으면 더이상 테이블 검색을 하지 않는 것을 의미한다. 의미론적으로 exist와 동일하게 처리하는 것이다.

<img src="https://github.com/user-attachments/assets/8f7a43a5-4916-4086-9707-a1edc94fa811" width=400>

제한사항은 다음과 같다.

- FirstMatch는 하나의 레코드만 검색되면 더이상의 검색을 멈추는 단축 실행 경로이기 떄문에 서브쿼리가 참조하는 아우터 테이블이 먼저 조회된 이후에 실행된다.
- FirstMatch최적화는 GROUP BY나 집합함수가 사용된 서브쿼리의 최적화에는 사용될 수 없다. -> GROUP해야하는데, GROUP에 해당하는 한개를 찾으면 끝내야하기 때문에?

**루스 스캔(loosescan)**

루스 스캔은 인덱스를 뛰어넘어 스캔하는 방법이다.

```sql
SELECT *
FROM DEPARTMENTS D
WHERE D.DEPT_NO IN (SELECT DE.DEPT_NO
                    FROM DEPT_EMP DE);
```

DEPARTMENT테이블의 레코드 건수는 9건, DEPT_EMP테이블의 레코드 건수는 33만건이다. 그런데, DEPT_TMP테이블은 (DEPT_NO + EMP_NO)조합으로 PK가 이뤄져있다.

해당 인덱스는 33만건이 있겠지만, 결국 DEPT_NO으로 그루핑하면 유니크한 DEPT_NO은 9건밖에 없다.

따라서 LOOSE SCAN을 효과적으로 사용할 수 있다.

<img src="https://github.com/user-attachments/assets/1eb93eca-c346-44f4-8ccd-2ea2d82550dc" width="400">


**구체화(Materialization)**

세미조인에 사용된 서브쿼리를 통째로 구체화해서 쿼리를 최적화하는 방법이다. 쉽게말하면 임시테이블을 만든다는 것!

```sql
SELECT *
FROM EMPLOYEES E
WHERE E.EMP_NO IN (SELECT DE.EMP_NO FROM DEPT_EMP DE WHERE DE.FROM_DATE = '1995-01-01');
```

EMPLOYEE에 대한 조건이 서브쿼리 이외에는 아무것도 없기떄문에 EMPLOYEE테이블을 풀스캔해야한다. 별로 성능향상에 도움되지 ㅇ낳는다.

이떄 서브쿼리를 임시 테이블로 구체화한 다음 조인하여 결과를 반환한다.

제한사항

- IN에서 서브쿼리는 상관 서브쿼리가 아니어야한다.
- 서브쿼리는 group by나 집합 함수들이 사용돼도 구체화를 사용할 수 있다.

**중복 제거(Duplicated Weed Out)**

Duplicate Weedout은 세미조인 서브쿼리를 일반적인 Inner Join쿼리로 바꿔서 실행하고 마지막에 중복된 레코드를 제거하는 방법으로 처리되는 최적화 알고리즘이다.

```sql
select *
from employees e
where e.emp_no IN (select s.emp_no from salaries s where s.salary > 150000);
```
salaries테이블의 pk가 (emp_no+from_date)이므로 salary가 150000이상인 레코드를 salaries테이블엣 ㅓ조회하면 중복된 emp_no이 발생할수 있다.

이를 다음과 같이 재작성해서 group by절을 넣어주면 동일한 결과를 얻을수 있다.

```sql
select e.*
from employees e,
     salaries s
where e.emp_no = s.emp_no
  and s.salary > 150000
group by e.emp_no;
```
원본쿼리를 Inner Join + Group By절로 바꿔 실행하는 것과 동일한 작업으로 쿼리를 처리한다.

<img src="https://github.com/user-attachments/assets/0af4c29f-fe49-439d-a6f6-8df32aff604f" width=400>

1. salaries테이블의 ix_salary인덱스를 스캔해서 salary가 150000보다 큰 사원을 검색해 employees테이블 조인을 실행
2. 조인된 결과를 임시테이블에 저장
3. 임시 테이블에 저장된 결과에서 emp_no기준으로 중복제거
4. 중복을 제거하고 남은 레코드를 최종적으로 반환

제한사항
- 서브쿼리가 상관 서브쿼리라고 하더라도 사용할수 있다.
- 서브쿼리가 group by나 집합함수가 사용된 경우에는 사용될 수 없다.
- 중복제거는 서브쿼리의 테이블을 조인으로 처리하기 때문에 최적화할 수 있는 방법이 많다.

<br>
<br>

**컨티션 팬아웃**

조인을 실행할 때 테이블의 순서는 쿼리의 성능에 큰 영향을 미친다.

> A테이블과 B테이블이 조인할때 A테이블에는 조건에 일치하는 레코드가 1만건이고, B테이블에는 일치하는 레코드가 10건일때,
> 
> A테이블을 조인의 드라이빙 테이블로 결정하면 B테이블을 1만번 읽어야한다.

MySQL옵티마이저는 여러 테이블이 조인되는 경우 가능하면, 일치하는 레코드 건수가 적은 순서대로 조인을 실행한다.

<br>

**파생 테이블 머지**

From절에 서브쿼리가 있을때 기존에는 서브쿼리에 대한 임시 테이블을 만들었다.

하지만 현재는 서브쿼리를 외부 쿼리로 병합하여 최적화를 진행한다.

```sql
select *
from (select * from employees where first_name = 'Matt')
where derived_table.hire_date = '1986-04-03';
```

해당쿼리를 현재는 다음과 같이 외부쿼리로 병합해 사용한다.

```sql
select * from employees where ((employees.hire_date='1986-04-03') and (employees.first_name='Matt'))
```

하지만 모든 경우 외부쿼리로 병합할수 있는 것은 아니기 떄문에 다음과 같은 경우에는 수동으로 병합해서 작성해야 쿼리 향상에 도움이 된다.

- SUM(), MIN(),MAX() 등 집계함수와 윈도우 함수가 사용된 서브쿼리
- distinct가 사용된 서브쿼리
- group by나 having이 사용된 서브쿼리
- union또는 union all을 포함하는 서브쿼리
- select에 사용된 서브쿼리
- 값이 변경되는 사용자 변수가 사용된 서브쿼리

<br>

**인비저블 인덱스**

옵티마이저는 인덱스가 존재하면 항상 인덱스를 고려하지만, 사용하지 못하도록 설정할수 있다.

<br>

**스킵 스캔**

>인덱스는 정렬되어있다는것이 핵심이다. 이로 인해 인덱스를 구성하는 칼럼의 순서가 매우 중요하다.
>
>(A,B,C)인덱스가 있을때 where절에 만약 A만 있다면 A만 사용가능하고, A,B가 있다면 A,B까지만 사용가능하다.
>
>하지만 B,C만 있다면 A가 우선적으로 없기때문에 인덱스를 사용할 수 없다.

이러한 제약을 스킵스캔을 활용해 개선할수 있다.

기존의 경우 B,C로 시작하는 인덱스를 새로 만들어야했지만, 스킵스캔을 통해 A가 있다치고 인덱스를 진행한다.

하지만 우선 인덱스가 너무 다양하다면 오히려 비효율적일수도 있다.

<br>

**해시 조인**

>
>보통 해시조인이 네스티드 루프조인보다 더 빠르다 생각하여 환영하지만, 사실 해시조인과 네스티드 조인은 다르게 사용된다 볼수 있다.
>
><img src="https://github.com/user-attachments/assets/9eee3384-c4b9-4247-a72b-79df4ee03b48" width="500">
>
>그림을 보면 해시조인이 처리속도(Throughput)이 빠르고, 중첩루프조인은 첫번째 레코드를 찾는 속도(Best Response)가 빠르다.
> mysql은 범용db인만큼 일반적인 웹에서는 빠른 응답이 중요하다. 
> 
>따라서 해시조인은 특정경우에 대해서만 사용하지 강제로 옵티마이저 힌트를 통해 유도하진말자!

## 다시읽기 이해못함

<br>

**인덱스 정렬 선호**

```sql
select *
from employees
where hire_date between '1985-01-01' and '1985-02-01'
order by emp_no;
```

다음과 같이 있을때 ORDER BY나 GROUP BY를 인덱스를 사용해 처리가 가능하다면, 실해계획에서 가중치를 높이 설정하여 실행한다.

WHERE절을 체크해야하는 레코드가 적다면, 괜찮지만 그렇지 않으면 오히려 비효율적이라 해당 옵션을 꺼야할수도 있다.

<BR>

**조인 최적화 알고리즘**

조인이 많아지면 옵티마이저가 실행계획을 수립하는데에만 많은 시간을 쏟을수 있다. 

MySQL에는 2가지 알고리즘으로 조인을 처리할수 있다.

**Exhaustive(완탐)알고리즘**

<img src="https://github.com/user-attachments/assets/baa32a19-509d-4c42-bac7-8bf1938bdcf7" width="500">

모든 경우의 수를 다 돌아 최적의 조합 1개를 찾는 방법이다. 하지만 테이블이 20개라면 20!이라는 시간이 드는만큼 오래걸린다.

>테이블이 10개만 넘어도 몇분이 걸리는데, 1개가 더 늘때마다 11배의 시간이 든다.

**Greedy검색 알고리즘**

<img src="https://github.com/user-attachments/assets/934cd2a6-d243-49c1-b818-7b17fe918685" width="500">

분할정복으로 찾는 방법이다. 설정된 크기만큼 테이블을 불러 빠른 시작 테이블을 찾고, 그것 외에서 또 찾고를 반복한다.

1. optimizer_search_depth에 정의된 개수의 테이블로 가능한 조인조합 생성
2. 1번에서 생성된 조합 중 최소비용계획 선정
3. 2번에서 선정된 테이블을 제외한 테이블중 1번과정 진행
4. 남은 테이블이 없을때까지 반복하여 조인순서 기록

물론 각 부분에서 최적을 찾기 때문에 이것이 최적의 방법이라고는 말할수 없음
