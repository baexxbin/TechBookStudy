# 5장. 트랜잭션과 잠금

잠금(Lock)과 트랜잭션은 비슷해보이지만, Lock은 동시성을 `제어`하기위한기능, 트랜잭션은 `정합성`을 보장하기 위한 기능이다.

## 트랜잭션

트랜잭션은 완전성을 보장해주는것. 논리적인 작업셋을 모두 처리하거나, 문제가 있으면 모두 복구하여 Partial Update를 방지하는 기능

트랜잭션을 지원하지 않는 MyISAM과 트랜잭션을 지원하는 InnoDB의 동작 차이에 대해 살펴보자

### MySQL의 트랜잭션

트랜잭션은 작업의 수가 많을때 의미있는개념이 아니다. 트랜잭션은 작업이 실행되거나 실행되지 않거나를 보장하는것을 말한다.

(3)이 들어있는 테이블에 (1),(2),(3)을 넣는 작업을 MyISAM과 InnoDB를 비교해 봐보자

```SQL
-- 테이블에는 3이 들어가있음.
INSERT INTO myisam_tb
VALUES (1),
       (2),
       (3);
-> Duplicate entry '3' for key 'PRIMARY'
INSERT INTO innodb_tb VALUES (1),(2),(3);
-> Duplicate entry '3' for key 'PRIMARY'

SELECT *
FROM myisam_tb;
결과
1
2
3

SELECT *
FROM innodb_tb;
결과
3
```

작업에 대해 실패하여 롤백된 innodb에 비해 myisam은 롤백되지 않고 오류가나는 3만 취소되었다.
> myisam은 1저장, 2저장, 3저장하려니까 오류나서 3만 저장안한것

myisam의 이러한 점은 정합성을 맞추는데 큰 어려움을 준다. 하나의 쿼리가 아니라 쿼리가 수백개라면 정합성을 맞추기 위해 복잡한 작업이 들어가야할것이다.

### 주의사항

트랜잭션은 커넥션과 동일하게 최소한의 코드에만 적용하는것이 좋다.
> 1) 처리시작
     >
     >   => 데이터베이스 커넥션 생성
     >
     >   => 트랜잭션 시작
> 2) 사용자의 로그인 여부확인
> 3) 사용자의 글쓰기 내용의 오류여부확인
> 4) 첨부로 업로드된 파일 확인 및 저장
> 5) 사용자의 입력 내용을 DBMS에 저장
> 6) 첨부 파일 정보를 DBMS에 저장
> 7) 저장된 내용 또는 기타 정보를 DBMS에서 조회
> 8) 게시물 등록에 대한 알림 메일 발송
> 9) 알림 메일 발송 이력을 DBMS에 저장
     >
     >    <= 트랜잭션 종료(COMMIT)
     >
     >    <= 데이터베이스 커넥션 반납
> 10) 끝

트랜잭션 내에 트랜잭션이 불필요한 부분이 포함되어잇다. 2,3,4와 같은 조회는 트랜잭션이 필요없다. 9는 네트워크 통신이 필요한데, 네트워크 상태에 따라 장애가 발생할수있기 때문에 웹 서버뿐만아니라 DB까지 영향이
갈수 있기때문이다. 또한 트랜잭션이 기면 커넥션을 오래 물고있기때문에 제한된 커넥션에 따라 장애가 발생할수도 있다.

## 락

MySQL에서 사용되는 잠금은 스토리지 엔진(InnoDB MyISAM..)레벨과 MySQL엔진 레벨로 나눌수 있다.
MySQL엔진 레벨의 락은 스토리지 엔진에 영향을 미치지만, 스토리지 엔진레벨의 락은 스토리지 엔진간의 영향을 미치지 않는다.

### MySQL엔진의 잠금

**글로벌락**
MySQL에서 제공하는 락중 가장 범위가 크가. 글로벌 락을 획득하면 획득한 세션외의 다른 세션은 `SELECT`를 제외한 대부분의 DDL과 DML을 실행할 경우 대기상태로 남는다.

글로벌 락의 영향 범위는 MySQL서버 전체이며, 작업 테이블이나 데이터베이스가 다르더라도 영향을 미친다.

여러 테이블에 존재하는 MyISAM이나 Memory테이블에 대해 일관된 백업을 받아야할때 주로 사용된다.

> InnoDB가 보편화되면서 트랜잭션이 보장되지 때문에 일관된 데이터를 위해 굳이 글로벌 락을 걸러 변경작업을 멈출 필요가 없어졌다.
> 따라서 조금 가벼운 락인 `백업락`이 도입되었다.

**테이블락**
개별 테이블 단위로 설정되는 잠금이며, 명시적 혹은 묵시적으로 특정 테이블의 락을 획득할 수 있다.
> 명시적: 내가 설정
> 묵시적: 설정안했는데 자동으로

명시적 테이블 락은 `LOCK TABLES tb_name [READ|WRITE]`명령으로 획득할수 있다. 작업 이후 UNLOCK TABLES명령으로 잠금을 반납할수 있다.

묵시적 테이블락은 MyISAM이나 MEMORY테이블에 데이터 변경 쿼리를 실행하면 발생하는데, 데이터가 변경된 후 즉시 해제된다. 하지만 InnoDB는 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공하기 때문에
단순 데이터 변경 쿼리에는 테이블 락이 설정되지 않는다. 대부분의 DML쿼리에서는 무시되고, 스키마를 변경하는 DDL의 경우에만 영향을 미친다.

**네임드 락**

`GET_LOCK`함수를 이용해 임의의 문자열에 대해 잠금을 설정할 수 있다.

네임드 락은 단순히 사용자가 `지정한 문자열`에 대해 획득하고 반납하는 잠금으로, 테이블이나 레코드같은 데이터베이스 객체가 대상이 아니다

DB1대에 서버5대인경우 어떤 정보를 동기화해야할때 네임드락을 사용할수 있다.

```sql
-- "mylock"이라는 문자열에 대해 잠금획득
select get_lock('my_lock', 2)
```

배치와 같이 많은 레코드를 한번에 변경하는 경우, 데드락의 원인이 될수 있다. 동일 데이터를 변경하거나 참조하는 프로그램끼리 분류해서 네임드 락을 걸고 쿼리를 실행하면 간단히 해결할수 있다.

**메타데이터 락**

메타데이터 락은 데이터베이스 객체(테이블이나 뷰 등)의 이름이나 구조를 변경하는 경우에 획득하는 잠금이다.

## iNNOdb 스토리지 엔진 잠금

mYsql에서 제공하는 잠금과 별개로 엔진 내부에서 레코드 기반의 잠금방식을 탑재하고 있다. 그덕분에 MyISAM보다 훨씬 뛰어난 동시성 처리를 제공할 수 있다.

InnoDB는 레코드 기반의 잠금인만큼 굉장히 작은 공간으로 관리되어, 레코드 락이 페이지락 또는 테이블락으로 더 큰락을 필요로 하는 경우는 없다.

**레코드 락**
레코드 자체만 잠그는 것이다. 다른 DBMS의 레코드락과 동일한 역할을 하지만, 중요한 차이는 **InnoDB스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다**

인덱스가 없는 테이블이더라도 내부적으로 자동생성되는 클러스터 인덱스를 이용해 잠금을 설정한다.

**갭락**
갭 락은 레코드자체가 아니라 레코드와 인접한 레코드 사이의 간격을 잠그는 것이다. 갭락의 역할은 레코드와 레코드 사이의 간격에 새로운 레코드 생성을 제어하는 것이다. 갭락은 해당 기능 자체보다, 넥스트 키락의 일부로
자주 사용된다.

**넥스트 키락**
넥스트 키락은 레코드 락과 갭락을 합쳐놓은 형태의 잠금이다. 두개의 연속된 인덱스 레코드 사이의 간격에 거는 락.

주로 Phantom Read현상을 방지하기 위해 사용됩니다.

예시 시나리오
두 개의 트랜잭션, T1과 T2를 고려해 봅시다:

T1이 ID 3을 가진 행을 삽입하려 함.
T2도 동시에 ID 3을 가진 행을 삽입하려 함.

단계:

1. T1이 간격 (2, 4]과 레코드 4에 넥스트 키 락을 겁니다.
2. T2가 ID 3을 삽입하려 하지만, T1의 락 때문에 차단됨.
3. T1이 삽입을 완료하고 트랜잭션을 커밋함.
4. T2는 T1의 락이 해제된 후에야 작업을 계속할 수 있음.

**자동 증가락**
MySQL은 AUTO_INCREMENT속성을 제공한다. 중복되지 않고, 저장된 순서대로 증가하는 일련번호를 삽입할때 걸리는 테이블 수준의 락이다.

특징은 다른 락과 같이 트랜잭션동안 계속 걸리는게 아닌, AUTO_INCREMENT값을 가져오는 순간만 락이 걸렸다 해제된다.

## 인덱스와 잠금

InnoDB의 잠금과 인덱스는 상당히 연관있다. InnoDB의 잠금은 레코드가 아닌 인덱스를 잠근다. 즉, 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락으로 건다.

```SQL
-- FIRST_NAME에만 인덱스가 걸려있다.

SELECT COUNT(*)
FROM EMPLYEE
WHERE FIRST_NAME = 'GEORGI';
> 253

SELECT COUNT(*)
FROM EMPLOYEE
WHERE FORST_NAME = 'GEORGI'
  AND LAST_NAME = 'KLASSEN';
>1

```

`UPDATE EMPLOYEE SET HIRE_DATE=NOW() WHERE FIRST_NAME='GEORGI' AND LAST_NAME='KLASSEN';`

위 UPDATE문장이 실행되면 1건의 레코드가 업데이트될것이다. 하지만 업데이트를 위해 253개의 레코드가 모두 잠긴다. 왜냐하면, first_name에만 인덱스가 걸려있고, last_name에는 인덱스가
안걸려있기때문에, last_name 확인을 위해 모든 레코드를 full_scan해야하기 때문이다.

인덱스가 적절히 설계되어 있지 않다면 클라이언트간 동시성이 떨어져 한 세션이 update하는 동안 다른 클라이언트는 해당 테이블을 업데이트하지 못하고 기다려야하는 상황이 발생한다.

## MySQL의 격리수준

트랜잭션의 격리 수준이란 여러 트랜잭션이 동시에 처리될때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 테이블을 볼 수 있게할지 결정하는 것이다.

크게 `READ UNCOMMITEED`,`READ COMMITTED`, `REPEATABLE READ`, `SERIALIZABLE` 4RKWLFH SKSNLSEK.

<img src="https://github.com/user-attachments/assets/3e037060-34cd-4aeb-a290-4298518b34e5" width=400>

위의 표는 각 격리수준마다 발생하는 상황을 보여준다.

> **Dirty Read**
>
>아직 커밋(Commit)되지 않은 다른 트랜잭션의 데이터를 읽는 것을 의미합니다.
>
> **Non-repeatable Read**
>
>다른 트랜잭션이 커밋(Commit)한 데이터를 읽을 수 있는 것을 의미합니다.
>
>즉, 한 트랜잭션에서 같은 쿼리로 2번이상 조회했을 때 그 결과가 상이한 상황을 말합니다.
>
>보통 데이터의 수정/삭제가 발생했을 경우 발생합니다.
>
> **Phantom Read**
>
>다른 트랜잭션이 커밋(Commit)한 데이터가 있더라도 자신의 트랜잭션에서 읽었던 내용만 사용하는 것을 의미합니다.
>
>즉, 한 트랜잭션에서 같은 쿼리를 2번이상 조회했을 때 없던 결과가 조회되는 상황을 말합니다.
>
>보통 데이터의 삽입이 발생했을 경우 발생합니다.

### Read Uncommitted

<img src="https://github.com/user-attachments/assets/793c79aa-87ea-42c6-9fcf-612ce744c23f" width=400>

Read Unccomitted는 트랜잭션의 변경사항이 commit되기 전에 다른 트랜잭션이 해당 내용을 조회할수 있는 수준이다.

커밋이나 롤백에 상관없이 해당 데이터에 접근할수 있기때문에 정합성에 많은 문제가 있다.

따라서 트랜잭션의 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼수 있는 현상인 `더티리드`가 발생한다.

### Read Committed

커밋이 완료된 데이터만 다른 트랜잭션에서 조회할수 있다. 따라서 위의 더티리드는 발생하지 않는다.

<img src="https://github.com/user-attachments/assets/82999f5e-047e-462e-ad57-26569ad81efe" width=400>

Read Committed는 변경 전 데이터를 언두 로그에 복사하여 커밋되기 전 다른 트랜잭션이 같은 데이터를 읽으려하면 언두로그를 조회시킨다.

하지만 만약 A트랜잭션 내에서 조회를 하는데, B트랜잭션의 주기가 짧아 빠르게 커밋한다면, 커밋이후 A트랜잭션은 어떤 값을 조회하게될까? 커밋을 했기때문에 변경된 값을 조회하게된다.

즉, Read Comitted는 NON-REPEATABLE READ라는 부정합의 문제가 있다.

### Repeatable Read

MySQL의 InnoDB에서 기본으로 사용되는 격리수준이다. Repeatable Read도 커밋전 변경된 내용을 언두 로그에 남겨둔다. 이때 Read Committed와 다른점은 트랜잭션 아이디를 함께 저장하여,
버전으로 분리한다는 것이다.

모든 트랜잭션에는 번호가 부여된다.

따라서 REPEATABLE READ는 MVCC를 보장하기 위해 실행중인 트랜잭션 가운데, 가장 오래된 트랜잭션 번호보다 트랜잭션 번호가 앞선 언두영역의 데이터는 삭제할 수가 없다.

하지만 같은것을 변경할때는 같은 결과만을 보여주지만 예로들어 범위로 조회할때 다른 트랜잭션이 커밋하면 기존에는 없던 데이터가 읽히는 `phantom read`문제가 발생할수 있다.

## Serializable

동시에 다른 트랜잭션이 같은 레코드이 읽고 쓰는 작업을 하지못하는, 격리수준이다. 일반적으로 dbms에서 읽어나는 phantom read문제가 발생하지 않는다. 하지만 InnoDB에서는 갭락과 넥스트키락으로
Repeatable Read수주에서도 phantom read가 발생하지 않기 때문에 굳이 Serializable을 사용할 필요성은 없다.