# 8장 인덱스

## 8.1 디스크 읽기 방식

디스크와 같은 기계적 장치의 성능은 제한적이기 때문에 DB성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건이다.
디스크의 읽기 방식인 **랜덤I/O**와 **순차I/O**와 같은 디스크 읽기 방식을 알아보자

### 랜덤I/O와 순차I/O

랜덤IO란 하드디스크의 원판을 읽어야할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는것을 의미한다. 사실 순차IO도 해당 작업과정은 동일하게 진행한다.

랜덤IO는 데이터를 저장하기위해 3번의 시스템콜을 요청하지만, 순차IO는 시스템콜을 1번만 요청한다. 즉, 랜덤은 원판을 찾기위해 3번을 움직이지만, 순차는 1번만 움직인다.

즉, 순차IO가 3배정도 빠르다는 것을 의미하며, 디스크의 성능은 디스크 헤더의 이동없이 얼마나 많은 데이터를 한번에 기록하느냐에 의해 결정된다

## 8.2 인덱스

인덱스는 특정 데이터를 빠르게 찾기위해 사용되는 값이다. 책을 비유해서 보자면 책의 챕터가 인덱스, 책 내용을 데이터 파일로 볼수 있다.

챕터를 빠르게 찾기 위해 정렬이 되어있는것처럼 인덱스도 칼럼의 값을 주어진 순서로 미리 정렬해서 보관한다.

미리 정렬되어 있음으로 조회는 빠르지만, 저장할때는 값을 정렬된 상태를 유지한채로 저장해야하기 때문에 삽입시 시간이 오래걸린다.

즉, 인덱스는 데이터 저장(Insert, Update, Delete)성능을 희생하고, 데이터의 읽기(Select)속도를 높히는 기능이다.

따라서 인덱스를 하나 추가할지말지는 데이터의 저장속도를 어디까지 희생할수 있는지, 읽기를 얼마나 빠르게 해야할지에 달려있다. 모든 컬럼이 인덱스를 걸면 저장성능은 떨어지고, 인덱스의 크기만 커져서 오히려 역효과가
날수 있다.

인덱스의 역할을 구분해본다면 프라이머리 키(PK)와 보조키(세컨더리 키)로 나눌수 있다.
> - 프라이머리 키: 레코드를 대표하는 값으로 해당 레코드를 식별할 수 있는 기준값이며, Null을 허용하지 않는다.
>
> - 세컨더리 키: PK를 제외한 모든키를 세컨더리 키라 한다.

인덱스를 구현하는 방식으로는 대표적으로 `B-Tree`와 `Hash`로 나눌수 있다.

## 8.3 B-Tree

용어정리

- root노드: 최상위 부모노드
- leaf노드: 최하위 자식노드
- branch노드:루트도 아니고, 리프도 아닌 중간의 노드

<img src="https://github.com/user-attachments/assets/1f29133d-11bd-47fc-8ce2-6e01242fdd0b" width="49%">

### 구조

DB에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리하는데, 인덱스의 **리프노드**가 실제 데이터 레코드를 찾기위한 주솟값을 가지고 있다.

인덱스의 키값은 모두 정렬되어 있지만, 데이터 파일의 레코드는 정렬돼있지 않다.
> 많은 사람들이 데이터파일의 레코드가 Insert된 순서대로 저장된다 생각하지만, 그렇지 않다. Delete, Update작업으로 중간중간 빈 공간을 우선 채우는 방식으로 설계되어 항상 정렬되어있진 않다.

MyISAM과 InnoDB의 방식의 차이점은 세컨더리 인덱스를 통한 검색에서 나타난다.

<img src="https://github.com/user-attachments/assets/93fffd04-cddd-4abe-9c46-75fe8e5d7085" width="49%">
(InnoDB)

MyISAM의 세컨더리 인덱스는 레코드 주소에 **물리주소**가 매핑되어 바로 데이터를 찾는 방면에, InnoDB는 PK가 매핑되어 PK에 대한 B-Tree를 한번더 검색한후, PK의 리프페이지에 저장돼 있는
레코드를 읽는다.

1단계를 더 거쳐야하기 때문에 InnoDB가 비효율적이라 생각할수있지만 각각의 장단점이 있고, 클러스터링 인덱스에서 두드러진다. 뒤에서 알아보자

### 인덱스 키 추가/삭제

레코드를 저장하거나, 변경하면 인덱스 키가 추가되고 삭제된다. 추가 및 삭제되는 과정을 알아보자

**추가**

B-Tree에 인덱스를 추가하면 새로운 키값이 바로 저장될수도 있고, 아닐수도 있다.

B-Tree에 저장될 때는 저장될 키값을 이용해 B-Tree상의 적절한 위치를 검색해야한다. 만약 저장할수 없다면, 리프노드를
분리해야하는데, 이는 상위 브랜치 노드까지 처리 범위가 넓어진다.

이렇게 위치가 결정되면 레코드의 키값과 대상 레코드의 주소정보를 B-Tree의 리프노드에 저장한다.
이러한 작업탓에 B-Tree는 상대적으로 쓰기 작업에 많은 비용이 든다.

> InnoDB는 필요한 경우 인덱스키작업을 지연시킬수 있는데, PK나 유니크 인덱스의 경우 중복 체크가 필요하여 즉시 B-Tree에 추가하거나 삭제한다.

**삭제**

삭제작업은 단순히 저장된 B-Tree의 리프노드를 찾아 삭제마크만 남기면된다.
> 삭제 마킹된 인덱스 키 공간은 계쏙 방치하거나 재활용할수 있다. 마킹 작업 또한 디스크 쓰기가 필요하므로, 이 작업 역시 디스크 IO가 필요한 작업이지만, 이 작업 또한 버퍼링되어 지연처리될수 있다.

**변경**

인덱스 키값에 따라 리프 노드의 위치가 결정되므로 B-Tree의 키 값이 변경되는 경우 단순히 인덱스상의 키값만 변경하는 것은 불가하다. 따라서 변경작업은 먼저 기존 키값을 삭제하고, 새로운 키 값을 추가하는 형태로
처리한다.

이 작업은 앞선 추가, 삭제 과정과 동일하게 진행되고, 체인지 버퍼를 통해 지연처리가 가능하다.

**검색**

추가비용을 감수하면서까지 B-Tree를 구축하는 것은 빠른 검색을 위해서이다. 루트노드부터 브랜치 노드를 거쳐 리프노드까지 이동하면서 비교작업을 수행하는데, 이를 `트리 탐색`이라 부른다.

트리탐색은 SELECT에서만 사용하는 것이 아닌, UPDATE와 DELETE를 처리하기 위해 항상 레코드를 먼저 검색해야 할 경우에도 사용된다.
> - B-Tree인덱스를 이용한 검색은 앞부분(Left-most part)이 일치하는 경우에 사용할 수 있다.
> - 복합인덱스를 예로 들면, 인덱스가 순서대로 A,B,C가 설정되어있을때 무조건 A부터 검색한다는 의미이다. 즉, A없이 B, C를 통해 검색하는 것은 Full Scan으로 전화된다.

부등호 비교에도 인덱스를 활용할 수 있지만, 인덱스를 구성하는 키 값의 뒷부분만 검색하는 용도로는 인덱스를 사용할수 없다.(위와 같은 내용)

또한 인덱스를 이용한 검색에서 중요한 사실은 인덱스의 키 값에 변형이 가해진 후 비교되는 경우, 즉 함수나 어떠한 작업으로 변형이 생겼는데 정렬하거나 검색하는 작업은 B-Tree에서 적용될수 없다. 왜냐하면 이미
변형이 된 순간 B-Tree에 존재하는 값이 아니기 때문이다.

### B-Tree사용에 영향을 미치는 요소

인덱스를 구성하는 칼럼의 크기와 레코드의 건수, 그리고 유니크한 인덱스 키 값의 개수등에 의해 검색이나 변경 작업의 성능이 영향을 받는다.

**인덱스 키값의 크기**
InnoDB의 디스크에 데이터를 저장하는 기본단위는 페이지 또는 블록이라한다.
> 디스크의 모든 읽기 및 쓰기 작업의 최소단위이며, 버퍼풀에서 데이터를 버퍼링하는 기본단위이다.

인덱스도 결국 데이터의 일종이기에, 페이지 단위로 관리되며 루트와 브랜치, 리프노드를 구분한 기준이 바로 페이지 단위이다.

B-Tree는 이진트리의 Binary가 아닌 균형의 Balance이다. 따라서 자식도느를 몇개갖는지 궁금할수 있는데, 이는 설정에 따라 가변적이다.

4~64KB사이의 인덱스 키값으로 선택할수 있지만, 기본적으로는 16KB이다. 하나의 페이지는 `인덱스 키값`과 `자식노드의 주소`로 이루어진 데이터가 구성되어있는데, 만약 인덱스 키값이 커질수록 하나의 페이지 내의
데이터가 줄어들기 때문에 적절한 튜닝이 필요하다.

16KB는 585개의 데이터를, 32KB는 372개의 데이터를 구성할수 있기때문에, 만약 Select쿼리가 500개의 데이터를 조회한다면, 16KB는 1번의 디스크읽기를 32KB는 2번의 디스크읽기를 해야하기 때문에
성능의 차이가 일어날수 있다.

또한 인덱스 키값의 길이가 길어진다는 것은 전체적인 인덱스의 크기가 커진다는 것을 의미한다. 하지만 인덱스를 캐시해두는 버퍼풀의 크기가 제한되기 때문에, 인덱스 크기커질수록 메모리에 캐시해둘수 있는것이 적어진다.

**B-Tree 깊이**
인덱스 키값이 커질수록 깊이가 깊어지고 디스크 읽기가 많이 필요하기 때문에 가능하면 키값은 작게 유지하자

**선택도**
모든 인덱스키값 가운데 유니크한 값의 수를 의미한다. 전체 인덱스 키값은 100개인데, 유니크한 값의 수가 10개라면 기수성은 10이다. 인덱스는 선택도가 높을수록 검색 대상이 줄어들기 때문에 빠르게 처리된다.
> 선택도가 좋지 않더라도 정렬이나 그루핑과 같은 작업을 위해 인덱스를 만드는 것이 나은 경우도 있다. 항상 검색에만 사용되는 것은 아니니 여러가지 용도를 고려하자

선택도가 중요한 이유는 선택도가 높을수록 불필요하게 읽는 데이터가 줄어들기 때문이다.

총 10000개의 데이터가 존재하고, 필드로는 country와 city가 있다고 가정하자

- A: country의 선택도가 10이라면 각 country마다 1000개의 city가 존재한다.
- B: country의 선택도가 1000이라면 각 country마다 10개의 city가 존재한다.

즉, A는 1개의 city를 찾기위해 999개의 불필요한 검색을, B는 1개의 city를 찾기위해 9개의 불필요한 검색을 하게된다. 딱봐도 성능의 차이가 보인다. 선택도에 따라 적절한 인덱스를 설계해야한다.

**읽어야하는 레코드의 건수**
그렇다면 무조건 인덱스를 통해 데이터를 읽는 것이 효과적일까? 보통 인덱스를 타는것이 테이블에 직접 접근보다 4~5배 비용이 든다고 예측한다. 따라서 인덱스를 통해 읽어야할 레코드의 건수가 전체 레코드의 20~
25%를 넘는다면 그냥 직접 읽어서 필요한 레코드를 가려내는 방식으로 처리하는 것이 효과적이다.

### B-Tree인덱스를 통한 데이터 읽기

MySQL이 인덱스를 이용해 레코드를 읽는 방법에 대해 알아보자

**인덱스 레인지 스캔**
인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정됐을때 사용하는 방식이다.

<img src="https://github.com/user-attachments/assets/14423fb2-5c8c-4f86-866a-0a3a5c734360" width="49%">

1. 루트노드에서부터 시작해 브랜치 노드를 거치고 최종적으로 리프 노드까지 찾아들어가 레코드의 시작지점을 찾는다.
2. 시작 리프노드부터 마지막 리프노드까지 순서대로 읽는다.
3. 쿼리에서 요구하는 데이터에 따라 디스크에 랜덤접근한다.(인덱스에 따라 ex커버링 인덱스, 굳이 디스크에 접근하지 않아도 된다.)

디스크에 매번 접근이 추가되기 때문에 인덱스가 비용이 큰 작업으로 분류된다.

**인덱스 풀스캔**
처음부터 끝까지 모두 읽는 방식을 풀스캔이라고 한다.
대표적으로, 조건적에 들어가는 칼럼의 인덱스가 left most part가 아닌경우 풀스캔이 일어난다.

인덱스에 명시된 컬럼만으로 처리가 가능한 경우, 테이블 풀스캔보다는 인덱스가 작기때문에 효과적이다.

즉, 레코드에 접근하지 않는다는 가정이라면 효과적이지만 레코드에 접근해야한다면 인덱스를 타고, PK도 타고 데이터를 찾기때문에 비효율적이다.

**루스 인덱스 스캔**
루스 인덱스 스캔은 듬성듬성하게 레코드를 조회하는 방식이다. 즉, 필요하지 않은 중간값들은 스킵하고 다음으로 넘어가는 형태로 처리한다. 일반적으로 GROUP BY또는 집합함수 가운데 max(), min()함수에 대해
최적화 하는 경우 사용된다.

```
SELECT dept_no, MIN(emp_no)
FROM dept_emp
WHERE dept_no BETWEEN 'd002' and 'd004'
GROUP BY dept_no;
```

이렇게 있을떄 해당 테이블은 인덱스로 dept_no과 emp_no을 갖고있다 가정하자
인덱스로 설정되어 있기때문에 이미 정렬되어 있는 상황이기 때문에 where절을 만족하는 모든 범위를 스캔할 필요 없다는 것을 알고있다. 따라서 필요없는 레코드는 띄어넘게 된다.

**인덱스 스킵 스캔**
이전에 복합 인덱스 중 left most part가 아닌 컬럼들만 있다면 풀 스캔을 돌수 있다 하였는데, MySQL8.0이 되면서 인덱스 스킵 스캔을 통해 인덱스 스킵 스캔을 통해 해결하였다.

left most part가 없더라도, left most part의 유일값을 가져와서 모든 유일값을 대입하여 스캔하는 것인데 예를 들면 다음과 같다.
gender와 birth_date가 있을때 다음과 같은 쿼리가 있다하자

```sql
select gender, birth_date
from employees
where birth_date >= '1999-02-01';
```

원래라면 풀스캔을 돌겠지만 인덱스 스킵 스캔이 적용되면 다음과 같은 쿼리가 만들어진다.

```sql
---gender는 M과W
select gender, birth_date
from employees
where gender = 'M' birth_date>='1999-02-01';

select gender, birth_date
from employees
where gender = 'W' birth_date>='1999-02-01';
```

위와 같은 쿼리가 만들어지는 것같이 최적화되게 된다.

하지만 다음과 같은 단점이 있다.

- WHERE조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야함 -> 유니크값이 많으면 시작지점을 찾는 과정이 너무 많아짐
- 쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능해야함(커버링 인덱스) -> Full Scan으로 변경된다.

**다중 컬럼 인덱스**
지금까지는 하나의 인덱스에 하나의 컬럼만 있었지만, 2개이상의 컬럼으로 이루어진 인덱스도 많다. 이를 복합 인덱스라 하는데, 복합인덱스는 앞선 컬럼에 의존하여 정렬된다.
즉, 2번째 인덱스는 1번째 인덱스내에서만 유효한 정렬이고, 3번째 인덱스는 2번째 인덱스에서만 유효한 정렬이다. 따라서 인덱스의 순서를 정하는 것에 따라 성능이 달라지니 신중히 정해야한다.

**B-Tree의 정렬 및 스캔 방향*
인덱스는 항상 오름차순으로만 정렬돼 있지만 사실 읽는 순서에 따라 오름차순일수도, 내림차순일수도 있다.

따라서 MySQL의 옵티마이저도 인덱스의 읽기 방향을 전환해서 사용하도록 실행 계획을 만들어 낸다.

> 하지만 실제로 인덱스 오름차순과 내림차순으로 조회했을때 시간 차이가 나는 것을 볼수 있다.
>
> 이는 두가지 이유정도 있다.
> - 페이지 잠금이 인덱스 정순 스캔에 적합한 구조
> - 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조(페이지간에는 양방향)

많은 쿼리가 인덱스의 앞쪽만 또는 뒤쪽만 집중적으로 읽어서 인덱스의 특정 페이지 잠금이 병목될 것이 예상된다면 쿼리에서 자주 사용되는 정렬 순서대로 인덱스를 생성하는 것이 유리할 것이다.

### B-Tree인덱스의 가용성과 효율성

쿼리의 WHERE조건이나 GROUP BY,또는 ORDER BY절이 어떤 경우에 인덱스를 사용할 수 있고, 어떤 방식으로 사용할 수 있는지 식별해야한다.

**비교 조건의 종류와 효율성**
다중 컬럼 인덱스에서 각 칼럼의 순서와 그 컬럼에 사용된 조건이 `=`인지 `>`인지 `<`인지에 따라 인덱스 컬럼의 활용 형태와 효율이 달라진다.

```sql
select *
from dept_emp
where dept_no = 'd002'
  and emp_no >= 10114;
```

위의 쿼리를 실행할때 인덱스가 2가지 종류가 있다고 가정하자

- 케이스A : `INDEX(dept_no, emp_no)`
- 케이스B : `INDEX(emp_no, dept_no)`

<img src="https://github.com/user-attachments/assets/d5e9ab7d-f00b-47fe-8d4f-69d809e4ef0f" width="49%">

케이스A는 "dept_no='d002' AND emp_no>=10114"인 레코드를 찾고, 이후에는 dept_no가 'd002'가 아닐때까지 인덱스를 읽으면 된다.

<img src="https://github.com/user-attachments/assets/d2ec6940-b7fd-48d7-87ce-29529d994849" width="49%">

케이스B는 "emp_no>=10144 AND dept_no='d002'"인 레코드를 찾고, 이후 모든 레코드에 대해 dept_no가 'd002'인지 비교하는 과정을 거쳐야 한다.

비교를 하는 과정으로 인해 불필요하게 `필터링`되는 데이터가 존재하기 떄문에 조금 비효율적이다.

**인덱스의 가용성**
B-Tree인덱스의 특징은 왼쪽값을 기준(Left Most)해서 오른쪽 값이 정렬돼 있다는 것이다.

여기서 왼쪽이란 하나의 컬럼내에서뿐만 아니라 다중 컬럼 인덱스의 컬럼에 대해서도 적용된다.

케이스B: INDEX(dept_no, emp_no)

두가지 경우에 대해서 알아보자
케이스A: INDEX(first_name)

```sql
select *
from employees
where first_name like '%mer';
```

해당 쿼리는 인덱스 레인지 스캔 방식으로 인덱스를 이용할수 없다.

first_name칼럼에 저장된 값의 왼쪽부터 한 글자씩 비교해가며 일치하는 레코드를 찾아야 하는데, 조건절에 주어진 상숫값에는 외쪽 부분이 고정되어
있지 않기때문에, 정렬 우선순위가 낮은 뒷부분의 값만으로는 외쪽 기준 정렬 기반의 인덱스 효과를 얻을수 없다.

케이스B: INDEX(dept_no, emp_no)

```sql
select *
from dept_emp
where emp_no >= 10144;
```

인덱스가 (dept_no, emp_no)칼럼으로 이루어졌다면 dept_no조건없이 emp_no으로만으로도 인덱스를 이용할수 있다.

하지만 케이스B는 다중 컬럼으로 구성된 인덱스이므로, dept_no정렬후, emp_no정렬한다. 하지만 where절에서 왼쪽 값기준규칙은 group by, order by 모두에 적용된다.

다음은 인덱스 특성상 사용할수 없는 경우이다.(작업범위결정조건으로 사용할수 없다는 것으로, 체크조건으로 인덱스를 사용할수는 있다.)

1. NOT-EQUAL로 비교된 경우("<>","NOT IN", "NOT BETWEEN", "IS NOT NULL")
2. LIKE %??(앞부분이 아닌 뒷부분 일치)형태로 문자열 패턴이 비교된 경우
3. 스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 후 비교된 경우
4. NOT-DETERMINISTIC속성의 스토어드 함수가 비교조건에 사용된 경우
5. 데이터 타입이 서로 다른 비교(인덱스 컬럼의 타입을 변환해야 비교가 가능한 경우)
6. 문자열 데이터 타입의 콜레이션이 다른 경우

다중 칼럼으로 이루어진 인덱스는 다음조건에서 사용이 어렵다.

```sql
INDEX ix_test(column1, column2, column3, ...)
```

- 작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우
- 작업 범위 결정 조건으로 인덱스를 사용하는 경우

## 8.6 함수 기반 인덱스

일반적으로 컬럼값을 이용하여 인덱스를 생성한다. 하지만 때때로 칼럼의 값을 변형해서 만든 값에 대한 인덱스를 구축해야하는 경우도 있는데, 이때 `함수 기반 인덱스`를 이용하면 된다.

함수기반인덱스 구현 방법은 두가지가 있다.

- 가상 칼럼을 이용한 인덱스
- 함수를 이용한 인덱스

### 가상 칼럼을 이용한 인덱스

```sql
create table user(
    user_id BIGINT,
    first_name VARCHAR(10),
    last_name VARCHAR(10),
    PRIMARY KEY(user_id)
)
```

다음과 같은 테이블이 있을때 first_name과 last_name을 합친값을 인덱스로 설정해야할 때가 있을수 있다. 기존이라면 full_name라는 새로운 필드를 만들어 사용할수도 있지만, 가상 칼럼을 통해 다음과
같이 해결할수 있다.

```sql
ALTER TABLE user
ADD full_name VARCHAR(30) AS (CONCAT(first_name,' ',last_name)) VIRTUAL
ADD INDEX ix_fullname (full_name)
```

`VIRTUAL`옵션을 통해 가상 컬럼을 만들어 인덱스 설정이 가능하다. 하지만 이는 테이블에 새로운 칼럼을 추가하는 것과 같은 효과를 내기에, 실제 테이블의 구조가 변경된다는 단점이 있다.

### 함수를 이용한 인덱스

가상 칼럼과 달리 테이블 구조의 변형없이 함수를 직점사용하는 인덱스를 만들수도 있다.

```SQL
CREATE TABLE user(
 user_id BIGINT,
 first_name VARCHAR(10),
 last_name VARCHAR(10),
 PRIMARY KEY (user_id),
 INDEX ix_fullname ((CONCAT(first_name,' ',last_name)))
);
```

테이블 구조 변경없이, 계산된 결괏값의 검색을 빠르게 만들어준다.

> 함수기반인덱스가 제대로 활용되려면 조건절에 함수기반 인덱스에 명시된 표현식이 그대로 사용되어야한다. 
>
>만약 where 조건절에 사용된 표현식이 다르다면 옵티마이저가 다른 표현식으로 간주해 함수기반 인덱스를 사용하지 못한다.

## 멀티 밸류 인덱스

모든 레코드는 1개의 인덱스를 가지게된다. 하지만 멀티벨류 인덱스는 하나의 데이터 레코드가 여러개의 키 값을 가질수 있는 형태의 인덱스이다.
> JSON데이터타입을 지원하며 JSON의 배열타입의 필드에 저장된 원소들에 대한 인덱스 요건이 발생하며 지원하는 기능

```sql
CREATE TABLE user(
user_id BIGINT AUTO_INCREMENT PRIMARY KEY
first_name VARCHAR(10),
last_name VARCHAR(10),
credit_info JSON,
INDEX mx_creditscores((CAST(credit_info->'$.credit_scores' AS UNSIGNED ARRAY)))
)

> INSERT INTO user VALUES (1, 'MATT','LEE','{"credit_scores":[360,353,351]}'
```

멀티 밸류 인덱스를 이용하기 위해서는 일반적인 조건 방식이 아닌 반드시 아래의 함수를 이용해 검색해야한다.

- MEMBER OF()
- JSON_CONTAINS()
- JSON_OVERLAPS()

## 클러스터링 인덱스

클러스터링은 여러개를 하나로 묶는다는 의미로 사용되는데, 클러스터링 인덱스는 테이블의 레코드를 비슷한 것(프라이머리 키를 기준으로)끼리 묶어서 저장하는 형태로 구현된다.
> InnoDB에서만 지원된다.

### 클러스터링 인덱스

클러스터링 인덱스는 PK에서만 적용된다. 중요한 점은 PK에 의해 레코드의 저장위치가 결정된다는 것이다. 즉, PK가 변경된다면 해당 레코드의 물리적인 저장위치가 바뀐다는 것을 의미한다.

클러스터링 인덱스는 PK에 의해 레코드 저장위치가 결정되므로, 사실 인덱스 알고리즘보다 테이블 레코드의 저장 방식이라 볼수 있다.

세컨더리 인덱스도 정렬되기때문에 클러스터링 인덱스랑 차이를 못느낄수 있는데, 세컨더리 인덱스는 인덱스로 정렬하고, 리프노드에 데이터가 아닌 논리값(PK)가 저장되어 데이터를 찾기위해 한번더 조회해야하는점이 다르다.

### 세컨더리 인덱스에 미치는 영향

클러스터링 인덱스가 없는 MyISAM이나 MEMORY는 리프노드에 데이터 주솟값이 저장되는 방식이기 떄문에 세컨더리나 pk나 구조적 차이가 없다.

하지만 InnoDB에는 클러스터 인덱스가 존재하는데, 만약 리프노드에 주솟값이 저장된다면, 클러스터링 인덱스가 변경될때마다 데이터의 주솟값이 변경되고, 모든 세컨더리 인덱스의 값 변경도 함께 이뤄져야 한다.

이러한 오버헤드를 없애기 위해 리프노드에는 PK가 저장된다.

### 클러스터링 인덱스의 장단점

**장점**

- PK를 통한 조회 성능이 매우 빠름
- 테이블의 모든 세컨더리 인덱스가 PK를 가지고 있기 때문에 인덱스만으로 처리될수 있는경우가 많음

**단점**

- 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기때문에 클러스터링 키의 크기가 클경우 전체적으로 인덱스의 크기가 커짐
- 세컨더리로 검색하면, 프라이머리 키로 다시 검색해야하므로 오버헤드 발생
- PK를 변경할때 레코드를 DELETE한후 INSERT하기 때문에 오버헤드
- INSERT할때 PK에 의해 레코드의 저장위치가 결정되기 때문에 오버헤드\

대부분 쓰기 작업에서 오버헤드가 발생한다. 즉, 조금 느린 쓰기를 감수하고 읽기를 빠르게 유지하는 것이다.

### 클러스터링 테이블 사용시 주의사항

1. 클러스터링 인덱스 키의 크기
    - 모든 세컨더리 인덱스가 프라이머리 키를 포함하기 때문에 너무 큰 클러스터링 인덱스(PK)는 많은 메모리를 사용하게 된다.
2. 프라이머리 키는 AUTO-INCREMENT보다는 업무적인 컬럼으로 생성(가능하다면)
    - InnoDB의 PK는 클러스터링 키로 사용되며, 해당 값에 의해 레코드의 위치가 결정된다. 즉 PK로 검색되는 경우(특히, 범위검색) 빠르게 처리된다는 것이다.
    - 따라서 빈번하게 사용되는 값을 가능하다면 사용해라
3. 프라이머리 키는 반드시 명명할것
    - PK를 명시하지 않으면 내부적으로 생성하게 되는데, 해당값은 사용자가 이용할수 없으니 꼭 PK를 반드시 명명하자!
4. AUTO-INCREMENT칼러믕ㄹ 인조 식별자로 사용할 경우
    - 여러개의 칼럼이 복합으로 pk가 만들어지는 경우 크기가 너무 커질수 있다.
    - 세컨더리 인덱스가 필요하지 않다면 그냥 사용해도 괜찮지만, 세컨더리 인덱스가 필요한 경우 AUTO-INCREMENT로 인조 식별자를 만들어 사용하자!

## 유니크 인덱스

유일한 값이기 때문에 빠를것이라 생각할수 있지만, 사실 `읽기 작업`에서 성능차이는 거의 없다.

유니크 인덱스는 유일한지 확인하는 작업 후 쓰게되기때문에 `쓰기 작업`에서 성능이 조금 느리다.

1. 데드락 가능성
    - 유일한지 확인할때 `읽기 락`, 값을 쓸때 `쓰기락`을 사용하는데, 이 과정에서 데드락이 비번하게 발생한다.
2. 버퍼링 불가능
    - iNNOdb에서는 인덱스 키의 저장을 버퍼링하기 위해 `체인지 버퍼`가 사용하여 저장과 변경을 빠르게 처리하지만, 유니크인덱스는 중복체크를 해야하기 때문에 작업을 버퍼링 하지 못해 느리게 작동하게 된다.

## 외래키
외래키는 InnoDB에서만 생성할 수 있으며, 외래키 제약이 설정되면 자동으로 연관되는 테이블의 칼럼에 인덱스까지 생성된다.

InnoDB의 외래키관리에는 중요한 특징 두가지가 있다.
- 테이블의 변경(쓰기 잠금)이 발생하는 경우에만 잠금대기가 발생한다.
- 외래키와 연관되지 않은 칼럼의 변경은 최대한 잠금 대기를 발생시키지 않는다.

예제를 통해 알아보자

### 자식 테이블의 변경이 대기하는 경우

<img src="https://github.com/user-attachments/assets/81258ac7-b64c-431a-9420-0dffc7b0c4a4" width=450>

1. 1번 커넥션에서 트랜잭션을 시작하고, 부모 테이블에서 id가 2인 레코드에 UPDATE를 실행한다.
   - 1번 커넥션이 ID가 2인 레코드에 대해 `쓰기 잠금`을 획득한다.
2. 2번 커넥션에서 자식 테이블이 외래키 칼럼인 PID를 2로 변경하는 쿼리 실행
   - 자식 테이블의 외래키 칼럼 변경은 부모 테이블의 확인이 필요하다
   - ID가 2인 부모 테이블에 `쓰기 잠금`이 걸려있기 떼문에 해당 쓰기 잠금이 풀릴때까지 쿼리를 실행하지 않고 기다리게 된다.
3. 1번 커넥션이 커밋이나 롤백된 후, 2번 커넥션 작업이 완료된다.

> 외래키가 아닌 컬럼의 변경은 외래키로 인한 잠금 확장이 발생하지 않는다!!

### 부모 테이블의 변경작업이 대기하는 경우

<img src="https://github.com/user-attachments/assets/01796c3d-85a9-4372-964b-6fb5b7759616" width=450>

1. 1번 커넥션에서 부모키 1을 참조하는 자식테이블의 레코드를 변경하여, 부모키 1을 참조하는 레코드에 대한 쓰기 잠금을 획득
2. 2번 커넥션에서 ID가 1인 부모 레코드를 삭제하면, 자식 테이블의 쓰기 잠금에 의해 대기하게됌
   - 생략됐지만, Cascade설정이 되어있기 때문에, 부모테이블을 삭제하면 자식이 함께 삭제되는 구조
