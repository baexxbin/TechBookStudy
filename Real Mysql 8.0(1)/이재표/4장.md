# 4장[아키텍처]

<img src="https://github.com/user-attachments/assets/d7af6d22-e5e2-45bb-a4dc-b6d8dfc63319" width=400>

MySql엔진

- 클라이언트로부터의 접속 및 쿼리 요청을 처리하는 커넥션 핸들러와 SQL파서 및 전처리기, 쿼리의 최적화된 실행을 위한 옵티마이저가 중심을 이룬다.

스토리지 엔진

- SQL문장을 분석하고 최적화하는 것을 MySql엔진이 처리하면, 디스크 스토리지에 저장하거나 읽어오는 기능을 스토리지 엔진이 처리함.
- MySQL서버에서 MySQL엔진은 하나지만 스토리지 엔진은 여러개를 사용할수 있다.
- `CREATE TABLE TEST_TABLE(FD1 INT, FD2 INT) ENGINE=INNODB` -> INNODB를 사용한다 명시할수 있다. 이렇게 각 테이블마다 담당 스토리지 엔진을 다르게 구성 가능

핸들러 API

- MySQL엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할때는 각 스토리지 엔진에 쓰기 또는 읽기를 요청하는데, 이를 핸들러 요청이라하고, 이때 사용하는 API를 행들러 api라고 한다.

### MySQL 스레딩 구조

MySQL서버는 프로세스 기반이 아닌 스레드 기반으로 작동하며, 크게 `포그라운드 스레드`와`백그라운드 스레드`로 구분할수 있다.

<img src="https://github.com/user-attachments/assets/758e9dbe-0d19-40a7-8db8-a71a444a6cc3" width=400>

포그라운드 스레드는 사용자의 요청을 처리하는 스레드, 백그라운드 스레드는 사용자의 요청에 대한 작업을 처리하는 스레드라고 볼수 있다.

포그라운드 스레드
MySQL서버에 최소한 접속된 클라이언트의 수만큼 존재함, 주로 클라이언트가 요청하는 쿼리문장을 처리한다.
클라이언트의 작업이 끝나면 커넥션을 종료하고, 스레드 캐시(=스레드풀?)로 돌아가지만, 스레드 캐시에 일정 개수이상의 스레드가 대기중이라면 스레드를 종료시켜 캐시내의 스레드 수를 유지한다.
> 스레드 캐시의 최대 스레드 개수는 thread_cache_size시스템 변수로 설정한다.

포그라운드 스레드는 데이터를 MySQL의 데이터버퍼나 캐시로부터 가져오며, 버퍼나 캐시에 없는 경우에는 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업한다.
InnoDB테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고, 나머지 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리한다.

백그라운드 스레드
MyISAM의 경우 해당사항이 적지만 InnoDB는 여러 작업이 처리된다.

- 인서트 버퍼를 병합하는 스레드
- 로그를 디스크로 기록하는 스레드
- InnoDB버퍼풀의 데이터를 디스크에 기록하는 스레드
- 데이터를 버퍼로 읽어오는 스레드
- 잠금이나 데드락을 모니터링하는 스레드

대부분의 쓰기작업을 백그라운드 스레드에서 처리한다. 이때 사용자의 요청을 처리하는중 읽기작업은 바로 처리해야하지만 쓰기작업의 경우 지연하여 처리할수있다.
따라서 대부분의 DBMS에는 대부분 쓰기 작업을 버퍼링해서 일괄처리하는 기능이 탑재되어 있으며, InnooDB또한 이런 방식으로 처리한다. 따라서 `INSERT`,`UPDATE`,`DELETE`쿼리로 데이터가
변경되는 경우 디스크에 저장될때까지 기다리지 않아도 된다.
> 하지만 MyISAM은 사용자 스레드(포그라운드 스레드)가 쓰기 작업까지 함께 처리하도록 설계돼있다. 따라서 일반적인 쿼리는 버퍼링 기능을 사용할수 없다.

### 메모리 할당 및 사용구조

mYsql에서 사용되는 메모리 공간은 **글로벌 메모리**와 **로컬 메모리** 영역으로 구분할수 있다. 각 영역은 MySQL서버 내에 존재하는 스레드가 공유해서 사용하는 공간인지 여부에 따라 구분된다.

**글로벌 메모리 영역**
모든 스레드가 공유하여 사용되는 영역으로 일반적으로 하나의 메모리 공간만 할당된다.
글로벌 메모리 영역은 다음과 같다.
> - 테이블 캐시
> - InnoDB버퍼풀
> - InnoDB 어댑티브 해시 인덱스
> - InnoDB 리두 로그버퍼

**로컬 메모리영역**
MySQL서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역이다.
로컬 메모리는 각 클라이언트 스레드별로 독립적으로 할당되며 절대 공유되지 않는다. 로컬 메모리 공간의 중요한 특징은 각 쿼리의 용도별로 필요할때만 공간이 할당되고 필요하지 않은 경우에는 메모리 공간을 할당하지 않을수
있다는점이다.
대표적으로 소트버퍼나 조인버퍼가 그러하다. 또한 로컬 메모리 공간은 커넥션이 열려있는동안 계속 할당된 상태로 남아있는 공간도 있고(커넥션 버퍼, 결과버퍼) 그렇지 않고 쿼리를 실행하는 순간에만 할당했다가 다시
해제하는 공간(소트 버퍼, 조인버퍼)도 있다.

대표적인 로컬메모리 공간은 다음과 같다.
> - 정렬버퍼
> - 조인 버퍼
> - 바이너리 로그 캐시
> - 네트워크 버퍼

### 플러그인 스토리지 엔진 모델

<img src="https://github.com/user-attachments/assets/06c85225-81e2-4ba7-8b32-191a585795e7" width=400>

MySQL의 독특한 구조중 하나는, MySQL인진에 여러 기능들을 붙혀 사용하는 플러그인 구조라는 것이다.

따라서 위와 같은 과정으로 실행된다했을때, 쿼리가 실행되는 과정은 대부분 MySQL엔진에서 처리되고, 마지막 데이터 읽기/쓰기 작업만 스토리지 엔진에 의해 처리된다.

> **핸들러**
> - 어떤 기능을 호출하기위해 사용하는 객체
> - MySQL 엔진이 스토리지 엔진을 조정하기 위해 핸들러를 사용
> - MySQL 엔진이 각 스토리지 엔진에게 데이터를 읽어오거나 저장하도록 명령하려면 반드시 핸들러를 통해야 함

MySQL에서 MyISAM이나 InnoDB와 같이 다른 스토리지 엔진을 사용하는 테이블에 대해 쿼리를 실행하더라도 MySQL의 처리내용은 대부분 동일하며, "데이터 읽기/쓰기"영역의 처리만 차이가 있을뿐이다.
실질적인 GROUP BY나 ORDER BY등 복잡한 처리는 스토리지 엔진이 아닌 mYsql엔진의 처리영역인 '쿼리 실행기'에서 처리된다.
그렇다면 스토리지 가운데 월 사용하든 차이없는것 아닌가라 생각할 수 있지만, 각 차이에 대해 뒤에서 알아볼 예정이다. 중요한것은 "하나의 쿼리 작업은 여러 하위작업으로 나뉘는데, 각 하위작업이 mYsql엔지 영역에서
처리되는지, 스토리지 엔진 영역에서 처리되는지 구분할줄 알아야한다는 점이다."

### 컴포넌트

MySQL 8.0부터는 플러그인 아키텍처의 단점을 대체하기 위해 컴포넌트 아키텍처가 지원된다.
> 플러그인 아키텍처 단점
> - 오직 MySQL서버와 인터페이스할수 있고, 플러그인끼리는 통신할 수 없음
> - 플러그인은 MySQL서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음(캡슐화 안됌)
> - 플러그인은 상호 의존 관계를 설정할수 없어서 초기화가 어려움

### 쿼리 실행 구조

**쿼리파서**
쿼리 파서는 사용자 요청으로 들어온 쿼리문장을 MySQL이 인식할 수 있는 최소단위의 어휘나 기호로 분리해 트리형태의 구조로 만들어내는 작업을 의미한다. 쿼리문장의 문법오류는 이과정에서 발견되어 에러 처리되게 된다.

**전처리기**
파서 과정에서 만들어진 트리를 기반으로 구조적인 문제가 있는지 확인한다. 각 토큰을 테이블 이름이나 칼럼 이름, 내장함수와 같은 개체를 매핑해 해당 객체의 존재 여부와 객체의 접근 권한 등을 확인하는 과정을 이
단계에서 수행한다.
실제 존재하지 않거나 권한상 사용할수 없는 개체의 토큰은 이 단계에서 걸러진다.

**옵티마이저**
쿼리문장을 최적화하는 역할을 담당한다. DBMS의두뇌역할로 옵티마이저의 역할은 중요하고 영향 범위또한 매우 넓다.

**실행엔진(쿼리 실행기)**
옵티마이저가 두뇌라면 실행엔진과 핸들러는 손과 발에 비유할 수 있다.
예로들어 설명하면 옵티마이저가 GROUP BY를 처리하기 위해 임시 테이블을 사용하기로 결정했다고 하자

1. 실행엔진이 핸들러에게 임시 테이블을 만들라고 요청
2. 다시 실행 엔진은 where 절에 일치하는 레코드를 읽어오라고 핸들러에게 요청
3. 읽어온 레코드들을 1번에서 준비한 임시 테이블로 저장하라고 핸들러에 요청
4. 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어 오라고 핸들러에게 요청
5. 최종적으로 실행 엔진은 결과를 사용자나 다른 모듈로 넘김

즉, 실행 엔진은 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행한다.

**핸들러(스토리지 엔진)**
가장 밑단에서 MySQL실행 엔진의 요청에 따라 데이터를 디스크에 저장하고 디스크로부터 읽어오는 역할을 담당한다. MyISAM 테이블을 조작하는 경우에는 핸들러가 MyISAM스토리지 엔진이 되고, InnoDB테이블을
조작하는 경우네는 핸들러가 InnoDB스토리지 엔진이 된다.

**복제**
뒤의장에서 알아보자

**쿼리 캐시**
쿼리캐시는 SQL의 실행 결과를 메모리에 캐시하고, 동일 SQL쿼리가 실행되면 즉시 반환하여 성능을 높히는 역할을 한다. 하지만 쿼리 캐시는 테이블의 데이터가 변경되면 캐시에 저장된 결과중 변경된 테이블과 관련된
것을 모두 삭제해야하여 동시 처리 성능 저하와 다양한 버그를 유발했다.
따라서 **MySQL 8.0이되면 쿼리 캐시가 삭제됐다.**

**스레드 풀**
스레드풀은 내부적으로 사용자의 요청을 처리하는 스레드 개수를 줄여 동시 처리되는 요청이 많다 하더라도 MySQL서버의 cpu가 제한된 개수의 스레드 처리에만 집중할 수 있게 해서 서버의 자원 소모를 줄이는 것이
목적이다.
> 스레드 풀은 동시 실행중인 스레드들을 CPU가 최대한 잘 처리해낼수 있는 수준으로 줄려 빨리 처리하게 하는 기능이기 때문에 스케줄링 과정에서 cpu시간을 제대로 확보하지 못하는 경우 쿼리 처리가 더 느려질수
> 있다는 점을 주의하자

쓰레드 풀은 기본적으로 CPU코어의 개수만큼 스레드그룹을 생성하는데, 스레드 그룹의 개수는 thread_pool_size 시스템 변수를 변경해서 조정할 수 있다. 하지만 일반적으로 CPU코어의 개수와 맞추는 것이
cpu프로세서 친화도를 높이는데 좋다. MySQL서버가 처리해야할 요청이 생기면 스레드 풀로 처리를 이관하는데, 이미 스레드 풀이 처리중인 작업이 있는 경우에는 thread_pool_oversubscribe시스템
변수에 설정된만큼 추가로 스레드를 생성하여 처리한다. 하지만 이 값이 너무 크면 스케줄링해야할 스레드가 많아져서 스레드 풀이 비효율적으로 작동할 수도 있따.

스레드 그룹의 모든 스레드가 일을 처리하고 있다면 스레드 풀은 해당 스레드 그룹에 새로운 작업 스레드를 추가할지, 아니면 기존 작업이 끝나는것을 기다릴지 판단해야한다. 스레드 풀의 타이머 스레드는 주기적으로 스레드
그룹의 상태를 체크해서 thread_pool_stall_limit 시스템 변수에 정의된 밀리초만큼 작업 스레드가 처리중인 작업을 끝내지 못하면 새로운 스레드를 생성해서 스레드 그룹에 추가한다. 따라서 응답시간에
민감한 서비스라면 해당 시스템 변수를 적절히 낮춰야하지만 0에 가까운 값으로 설정하는 것은 차라리 스레드 풀을 사용하지 않는 편이 낫기때문에 권장하지 않는다.

## InnoDB스토리지 엔진 아키텍처

<img src="https://github.com/user-attachments/assets/2a8dbcb9-7ee6-4b45-8f6b-3e4a29715330" width=400>

MySQL의 스토리지 엔진 가운데 가장 많이 사용되는 스토리지 엔진으로 유일하게 **레코드 기반의 잠금**을 제공한다. 따라서 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.
> **Lock종류**
> - 레코드 락
> - 갭 락
> - 넥스트 키 락
> - 자동 증가 락

InnoDB의 주요 특징들에 대해 알아보자

### 프라이머리 키에 의한 클러스터링

InnoDB는 기본적으로 PK를 기준으로 클러스터링 되어 저장된다. 즉, PK 순서대로 디스크에 저장된다는 뜻이며, 모든 세컨더리 인덱스는 레코드의 주소대신 프라이머리 키 값을 논리적인 주소로 사용한다.

따라서 PK를 이용한 Range스캔이 빠르게 처리될수 있어, 쿼리의 실행 계획에서 PK키가 우선순위가 높게 설정된다.
> 클러스터 인덱스
> - 테이블 전체가 정렬된 인덱스가 되는 방식(테이블 레코드들이 인덱스 컬럼의 정렬 순으로 적재되어있는것)
> - 테이블 하나만 생성
> - 대체로 PK
> - 일반적으로 B+Tree로 구성되어있다.
    > 세컨더리 인덱스(비클러스터 인덱스)
> - 테이블 자체가 아닌, 정렬된 별도의 인덱스 페이지를 생성해 관리한다.(실제 데이터 갖지않음)
> - 테이블당 여러개 생성 가능
>
> [참고](https://dev-jwblog.tistory.com/162)

myISAM스토리지 엔진에서는 클러스터링 키를 지원하지 않는다. 따라서 MyISAM테이블에는 PK와 세컨더리 인덱스의 구조적 차이가 없다.

### 외래키 지원

외래키에 대한 지원은 InnoDB스토리지 엔진레벨에서 지원하는 기능으로, 부모테이블과 자식테이블 모두 해당 컬럼에 대한 인덱스 생성이 필요하고, 변경시 부모와 자식 테이블 모두에 데이터가 존재하는지 확인해야하기
때문에 잠금이 전파되어 데드락 발생할 가능성이 높아진다.

각 테이블의 연관관계를 잘 파악하여 순서대로 삭제하면 괜찮지만, 많은 관계가 맺어져 있으면 긴급한 경우 파악에 어려움을 겪을수 있기때문에 외래키에 대한 기능을 `foreign_key_checks`시스템 변수를
OFF하여 일시적으로 멈출수 있다.

외래 키 체크를 일시적으로 해제했다고 하여 부모와 자식 관계가 깨진 상태를 유지해도 된다는 것을 의미하지 않고, 조치후 일관성을 맞춘후 해당 기능을 활성화 해야한다.
> 참고로, foreign_key_checks기능을 끄면 CASCADE옵션과 같은 부모테이블에 대한 기능도 비활성화된다.

### MVCC && 잠금없는 일관된 읽기

MVCC의 가장 큰 목적은 Lock없이 일관된 읽기를 제공하는 데 있다.
만약 읽기작업을 하는 도중 다른 쓰레드가 해당 데이터를 변경하면 읽기작업의 값은 어떻게될까? 격리수준이 Read Commit이상인 DB에서는 변경 이전의 값이 조회된다. MVCC(Multi Version
Concurrency Control) 말 그대로 이전의 데이터를 남겨두었기 때문에 가능한 것이다.

<img src="https://github.com/user-attachments/assets/7133e942-bcda-4b11-bd90-ed24bc22440d" width=400>

버퍼풀에 데이터가 있을때, 해당 값을 변경하면 기존의 버퍼풀의 값은 변경되고, 변경 이전의 값이 Undo로그에 저장되게 된다. 즉 변경전과 변경후 2가지 버전이 만들어지는것이다.

이후 만약 격리수준이 Read Commit이상이라면 언두로그에 있는 데이터를 읽어 하나의 트랜잭션내에서 데이터의 일관성을 지키게 된다.

MVCC를 통해 InnoDB에서 읽기 작업은 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고, 읽기 작업이 가능하다.

<img src="https://github.com/user-attachments/assets/a48ad97d-d1cb-4e3b-88d5-4a3f5e6cc476" width=400>

따라서 하나의 트랜잭션이 읽기 작업을 수행할때 변경작업을 하여도 잠금을 대기하지 않고 언두 로그의 데이터를 조회하여 일관된 데이터를 대기없이 바로 실행할수 있다.

### 자동 데드락 감지

InnoDB스토리지 엔진은 내부적으로 DeadLock걸리지 않았는지 체크하기 위해 잠금 대기 목록을 그래프 형태로 관리한다.
InnoDB는 데드락 감지 스레드를 갖고있어 주기적으로 잠금 대기 그래프를 검사해 교착상태에 빠진 트랜잭션을 강제 삭제한다.
> 강제 종료 순서는 트랜잭션의 언두 로그양이다. 언두 레코드가 적을수록 롤백시 처리할 내용이 적기때문이다.

데드락 검사시 잠금목록이 저장된 테이블에 새로운 잠금을 걸고 검사한다. 일반적으로 데드락 감지 스레드의 작업은 큰 부담되지 않지만, 동시 스레드가 많거나 트랜잭션의 잠금개수가 많아지면 데드락 스레드가 느려지는 이는
다른 서비스 쿼리의 작동에도 영향을 미쳐 악영향을 끼치게된다.
해당 문제를 해결하기 위해 `innodb_deadlock_detect`변수를 통해 데드락 감지 스레드를 비활성화 할수 있다. 이렇게 되면 데드락 발생시 무한정 대기하게 되지만
대신 `innodb_lock_wait_timeout`을 통해 데드락에서 일정시간이 지나면 에러를 반환하도록 설정하여 데드락을 벗어나도록 설정할수 있다.

### 자동화된 장애복구

-> 다시읽으셈

### InnoDB 버퍼풀

InnoDB의 핵심부분으로, 디스크의 데이터파일, 인덱스 정보를 메모리에 **캐시**해두는 공간이다. 또한 쓰기작업을 지연시켠 **일괄적으로 처리**하는 버퍼역할도 한다.

### 버퍼풀의 크기설정

버퍼풀의 크기는 실험을 통해 최적화시켜가야한다.
InnoDB버퍼풀은 전통적으로 버퍼 풀 **전체**를 관리하는 잠금으로 인해 내부 잠금 경합을 유발했는데, 경합을 줄이기 위해 버퍼풀을 **여러개로 쪼개**관리하도록 개선했다.
각 버퍼풀을 버퍼 풀 인스턴스라고 표현한다. 기본적으로 버퍼 풀 인스턴스의 개수는 8개로 초기화되지만 전체 버퍼풀을 위한 메모리 크기가 1GB미만이면 버퍼풀은 1개만 생성된다.

### 버퍼 풀의 구조

InnoDB는 버퍼풀이라는 거대한 메모리공간을 페이지 크기의 조각으로 쪼개 InnoDB가 데이터를 필요로 할때 디스크의 데이터페이지를 읽어 저장한다.
버퍼 풀의 페이지 크기 조각을 관리하기 위해 InnoDB스토리지 엔진을 크게 **LRU**, **FLUSH**, **FREE** 3개의 자료구조를 관리한다.

> FREE리스트는 버퍼풀에서 비어있는 페이지의 목록으로, 사용자 쿼리가 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 사용된다.
>
> LRU리스트는 LRU와MRU리스트가 경합된 형태로 **Old서브리스트**는 LRU, **NEW서브리스트**는 MRU로 이해할수 있다.
>
> <img src="https://github.com/user-attachments/assets/a27e75bf-130b-4749-a7ec-7c954bc988fb" width=400>
>
> LRU리스트를 관리하는 목적은 한번읽은 페이지(데이터)를 최대한 오랫동안 버퍼풀의 메모리에 유지해 디스크 읽기를 최소화하는 것이다.
>
> FLUSH리스트는 디스크로 동기화되지 않은 데이터(아직 디스크에 저장안된 데이터)페이지 목록을 관리한다.
>
> 데이터가 변경되면 iNNOdb는 변경내용을 리두로그에 기록하고, 버퍼 풀의 데이터 페이지에도 변경내용을 반영한다. 따라서 리두 로그의 목록은 특정 데이터 페이지(버퍼풀)와 연결된다.

**버퍼 풀과 리두 로그**

<img src="https://github.com/user-attachments/assets/cc121e43-4345-44d3-bb70-13cc124ad3ae" width=400>

InnoDB의 버퍼 풀과 리두 로그는 밀접한 관계. 버퍼풀은 일종의 캐시이기때문에 크기가 클수록 성능이 좋아진다. 버퍼풀은 데이터 캐시와 쓰기 버퍼링 두가지 역할이 있는데, 용량을 늘리는 것은 캐시기능을 향상시키는
것이고, 쓰기 버퍼링을 개선하기 위해서는 리두 로그를 살펴야한다.

버퍼풀은 **클린페이지**와 **더티페이지**로 나뉜다.
> 클린페이지: 아무것도 쓰이지 않은 페이지
> 더티페이지: Insert,Delete,Update명령으로 변경된 데이터를 가진 페이지로 언젠가 디스크에 기록될 페이지

더티페이지를 무한정 버퍼풀에 둘수 없기때문에 리두 로그 파일에 쓰이게된다. 이때 리두 로그 파일은 순환구조로 구성되어 새로운 데이터로 계속해서 덮어씌워지는데, 쨋든 더티페이지를 리두 로그에 쓸때마다 고유의 번호를
받게된다. 해당 번호를 LSN이라고 하는데, InnoDB엔진은 구지적으로 체크포인트 이벤트를 체크포인트 LSN보다 작은 번호를 가진 리두로그와 버퍼풀의 더티페이지를 디스크로 동기화시켜준다.

> Redo로그는 결국 버퍼풀의 데이터의 스냅샷이라 생각할수 있는데, 이는 결국 장애를 예방하기 위해 사용됩니다. 버퍼풀은 메모리이기 때문에 장애발생시 데이터가 휘발되기에 Redo로그에 저장되어있던 데이터를 불러와
> 데이터 일관성을 지키기 위해 사용됩니다. 그렇다면 그냥 디스크에 쓰지 왜 Redo로그를 남길까? 사실 Redo로그도 메모리이다. 하지만 Redo로그에 쓰고 체크포인트 발생시 백그라운드 스레드가 디스크에 있는
> Redo로그파일 해당내용을 백업하고, 장애발생시 리두로그파일을 불러와 장애를 복구한다.

### 버퍼 풀 플러시

더티페이지를 디스크에 저장하는 InnoDB의 더티페이지 플러시 기능이 갑작스러운 디스크 기록 폭증과 같이 잘 처리되지 않아 쿼리 처리에 영향으르 미치기도 했다.
이를 해결하기 위해 2가지 플러시 기능을 백그라운드에서 실행한다.
> - 플러시 리스트 플러시
> - LRU리스트 플러시

### 플러시 리스트 플러시

InnoDB는 주기적으로 리두로그공간의 재활용을 위해 오래된 리두 로그가 사용하는 공간을 비워야하는데, 이때 버퍼풀의 더티페이지를 디스크에 동기화를 해야한다.
이를 위해 InnoDB는 주기적으로 플러시 리스트 플러시 함수를 호출해서 오래전에 변경된 데이터 페이지 순서대로 디스크에 동기화하는 작업을 한다. 원활한 처리를 위해 다양한 것을 고려한 시스템변수가 존재한다.

1. 동기화 스레드 개수: 더티 페이지를 디스크로 동기화하는 스레드를 클리너 스레드라 하는데, innodb_page_cleaners변수를 통해 해당 스레드 개수를 조정할수 있다.
   가능하면 하나의 스레드가 하나의 버퍼 인스턴스를 처리하도록 기본설정을 유지하자.
2. 더티페이지 저장크기: 버퍼풀의 크기의 한계가 있기 때문에 더티페이지를 사용에따라 설정해주어야한다. 기본적으로 전체 페이지의 90%를 더티페이지가 가지고있도록 설정되어있는데, 이를 변경가능하지만, 더티페이지가
   많을수록 디스크
   쓰기작업을 버퍼링(나중에 한번에 쓰기)할수 있으니 가능하면 기본값을 유지하자
3. 디스크 폭발방지: 버퍼풀의 더티페이지가 많을수록 디스크 쓰기 폭발현상이 발생할 가능성이 높아진다. `innodb_io_capacity`시스템 변수의 값을 기준으로 더티 페이지 쓰기를 실행한다. 하지만 디스크에
   쓰는 양보다 버퍼풀에 채워지는 양이 많아진다면 버퍼풀에 저장되는 양이 점점 많아지고,설정된 저장 가능 비율을 넘어가면 갑작스럽게 더티페이지를 디스크에 기록하며 디스크 폭발이 일어난다. 따라서
   InnoDB에서는 `innodb_max_dirth_pages_pct_lwm`변수를 통해 디스크에 기록이 시작될 버퍼풀의 비율을 정하고있다.

> innodb_io_capacity와 innodb_io_capacity_max 변수를 통해 디스크에 쓰는 속도를 정할수 있지만, 읽기작업도 해야하기 때문에 적당히 튜닝해야하지만 트래픽에 따라 실시간으로 튜닝은
> 어렵기 때문에 어댑티브 플러시 기능을 통해 내장 알고리즘을 통해 쓰기 속도를 유지할수 있도록 한다.

### LRU리스트 플러시

InnoDB스토리지 엔진은 LRU리스트에서 사용빈도가 낮은 데이터 페이지를 제거해서 공간을 만들어야한다.
LRU리스트 플러시 함수는 LRU리스트의 끝부분에서 시작하여 설정된 개수만큼 스캔하면서 더티 페이지를 디스크에 동기화하고, 동기화된 페이지를 Free리스트로 옮겨 공간을 만든다.

### 버퍼 풀 상태 백업 및 복구

버퍼풀은 쿼리 성능과 매우 밀접하다. 캐싱되어있기때문에 셧다운후 재시작하며 평소성능보다 떨어져있는것을 볼수 있다. 따라서 캐시 웜업을 통해 재시작시 캐싱을 미리 만들어주는 작업을 진행할수있다.
이를 수동으로 할수도 있지만, InnoDB스토리지 엔진은 서버가 셧다운되기 직전에 버퍼풀의 백업을 실행하고, 재시작시 버퍼풀의 상태를 복구하는 기능을 제공한다.

### 버퍼 풀의 적재내용확인

버퍼풀 적재내용을 확인할수 있다.

### Double Write Buffer

InnoDB는 리두 로그 공간의 낭비를 막기위해 페이지의 변경된 내용만을 기록한다. 따라서 리두 로그의 데이터를 디스크에 적재할때 문제가 생기면 몇몇 페이지는 적재되지만, 몇몇페이지느 적재되지 않는 파셜 페이지
현상이 일어날수 있다. 이같은 문제를 막기위해 InnoDB에서는 Double-Write기법을 이용한다.

<img src="https://github.com/user-attachments/assets/d3854f25-b3a5-41cf-8a5d-454e53cbc248" width=400>

그림과 같이 A~E 더티페이지가 있을때 디스크로 플러시한다 가정하자. 이때 iNNOdb는 변경내용을 디스크에 플러시하기 전 더티페이지를 묶어서 한번의 디스크 쓰기로 Double Write버퍼에 기록한다. 그 다음
디스크에 쓰기를 실행한다.

만약 정상적으로 기록되면 DoubleWrite공간의 내용은 필요없지만, 비정상적인 종료가 일어나면 InnoDB가 재시작할때 항상 DoubleWrite버퍼의 내용과 데이터 파일의 페이지를 모두 비교해서 서로 다른
페이지가 존재하면 이를 디스크에 쓰기시작한다.

> 리두로그는 버퍼풀의 값이 날아갔을때 복구하기 위해 사용하고, DoubleWrite는 쓰기를 진행하며 정상적재가 되었는지 디스크와 비교하기위해 사용한다.

### 언두 로그

트랜잭션 격리수준을 보호하기 위해 DML 실행이전의 데이터를 백업하는 로그이다.
> 사용용도
> 트랜잭션 보장: 트랜잭션이 롤백되면 트랜잭션 도중 변경된 데이터를 변경전 데이터로 복구해야하는데, 이때 언두로그에 백업해둔 이전버전의 데이터를 이용해 복구. 이전 데이터가 있으니 언두로그로 바꾸면 되겠지?
> 격리수준 보장: 특정 커넥션에서 데이터를 변경하는 도중에 다른 커넥션에서 데이터를 조회하면 트랜잭션 격리 수준에 맞게 변경중인 레코드를 읽지 않고 언두로그에 백업해둔 데이터를 읽어서 반환

언두로그의 관리는 많은 비용이 필요하다. 언두로그의 문제점과 InnoDB에서 어떤 기능을 제공하는지 알아보자

### 언두 로그 모니터링

언두로그는 DML실행으로 데이터를 변경했을때 변경되기 전의 데이터를 보관하는 곳이다. 그렇다면 100GB를 동시에 DML작업을 하면 언두로그에도 100GB의 변경된 데이터가 쓰여지게된다. 대용량의 데이터를 처리하는
트랜잭션뿐만 아니라 트랜잭션의 실행시간이 길어져도 언두로그의 양이 급격히 늘어날수 있다.
예로들어 A->B->C순으로 트랜잭션이 실행될때, A의 트랜잭션이 끝나지 않았지만 B,C의 트랜잭션이 끝난다면 언두로그는 어떻게 될까? A->B->C 순으로 커밋된다면 언두로그는 삭제되겠지만 A트랜잭션이 끝나지
않았으므로 B,C의 언두로그도 삭제되지 않고 누적된다. 디스크의 사용량 증가가 큰 문제가 아닐수 있지만, 빈번하게 변경된 레코드를 조회할때 언두로그가 필요한만큼 스캔해야하기에 쿼리성능이 떨어질수 있다.
MySQL8.0에서는 언두로그를 돌아가면서 순차적으로 사용해 디스크 공간을 줄이고, 필요한 시점에 사용공간을 자동으로 줄여주기도하여 위의 문제를 해결했다.
> 그래도 트랜잭션이 장시간 유지되는것은 좋지않다.

### 언두 테이블스페이스 관리

언두로그가 저장된 공간을 언두 테이블스페이스라고 한다. 현재 언두로그는 시스템 테이블스페이스 외부의 별도 로그 파일에 기록된다.

### 체인지 버퍼

RDBMS에서 레코드가 Insert되거나 Update될때 데이터뿐만 아니라 인덱스도 업데이트해야한다. 만약 버퍼풀에 인덱스페이지가 있다면 바로 수행하지만 그렇지않다면 랜덤한 디스크에 접근해야하므로 성능이
떨어지게된다. 따라서 즉시 실행하지않고 임시공간에 저장해두는데 이때 사용하는 임시 메모리 공간은 **체인지 버퍼**라고 한다.

> 사용자에게 결과를 반환하기전 중복여부를 체크해야하는 Unique Index는 체인지 버퍼를 사용할수 없다. 체인지 버퍼에 임시로 저장된 인덱스 레코드 조각은 백그라운드 스레드에 의해 병함되는데, 해당 스레드를 *
*체인지 버퍼 머지 스레드**라고한다. Insert뿐만아니라 Delete, Update와 같이 키를 추가하거나 삭제하는 작업에대해서도 버퍼링할수 있다.

### 리두 로그 및 로그 버퍼

리두 로그는 트래잭션의 4가지 요소 ACID에서 D(Durable)에 해당하는 영속성과 가장 밀접하다.(왜나면 버퍼풀이 사라지면 저장이 안디니까 저장을 보장하는 Durable과 연관)
데이터베이스 서버는 대체로 읽기성능에 초점을 맞추기때문에 쓰기작업의 경우 대체로 느리다. 따라서 쓰기에 유리한 자료구조를 가진 리두로그를 이용한다.
쓰기작업과 관련하여 MySQL서버가 비정상 종료된 경우 InnoDB의 데이터파일은 다음 두가지 일관되지 않은 데이터가 있다.

- 커밋됐지만 디스크에 기록되지 않은 데이터
- 롤백됐지만 디스크에 이미 기록된 데이터

1번의 경우 리두 로그에 저장된 데이터를 디스크에 쓰면된다. 하지만 2번의 경우 리두 로그로 해결할 수 없는데, 이때는 변경되기 전 데이터를 가진 언두로그의 내용을 가져와 복사하면 된다. 이때 리두 로그는 최소한 그
변경이 커밋됐는지, 롤백됐는지, 트랜잭션 중간상태였는지 확인을 위해 필요하다

### 리두 로그 아카이빙

### 리두 로그 활성화 및 비활성화

InnoDB의 리두 로그는 갑작스러운 장애에 대응하기 위해 항상 활성화 되어있다. MySQL서버에서 트랜잭션이 커밋돼도 데이터 파일은 즉시 디스크로 동기화되지 않지만 리두 로그는 항상 디스크에 기록된다.

### 어댑티브 해시 인덱스

일반적으로 `인덱스`라고 하면 테이블에 사용자가 생성해둔 B-Tree를 의미한다. 어댑티브 해시 인덱스는 InnoDB에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스이다.

B-Tree인덱스에서 특정 값을 찾는 과정은 매우 빠르다 생각하지만, 이는 다른 자료구조에 비해 상대적인것이며, 수천개의 스레드가 동시에 이런 작업을 하면 엄청난 프로세스 스케줄링을 하게 되어 쿼리의 성능은
떨어진다.

어댑티브 해시인덱스는 B-Tree검색시간을 줄여주기 위해 도입된 기능이다. 자주 조회되는 데이터 페이지의 키값을 이용해 해시 인덱스를 만들고, 필요할 때마다 어댑티브 해시 인덱스를 검색해서 레코드가 저장된 데이터
페이지를 즉시 찾아갈수 있다.

해시 인덱스는 '인덱스 키값'과 해당 인덱스 키값이 저장된 '데이터 페이지 주소' 쌍으로 관리되는데, 인덱스 키값은 'B-Tree인덱스의 고유번호'와 'B-Tree인덱스의 실제 키값'조합으로 생성된다.

B-Tree인덱스의 고유번호가 포함되는 이유는 InnoDB에서 어댑티브 해시 인덱스가 하나만 존재하기 때문이다. 따라서 특정 키값이 어느 인덱스에 속한것인지 구별해야하기 때문이다.
데이터 페이지 주소는 실제 키값이 저장된 데이터 페이지의 메모리 주소를 가지는데, 이는 InnoDB 버퍼풀에 로딩된 페이지의 주소를 의미한다.
따라서 어댑티브 해시 인덱스는 버퍼풀에 올려진 데이터 페이지에 대해서만 관리되고, 버퍼풀에 해당 데이터 페이지가 없어지면 어댑티브 해시 인덱스에서도 해당 페이지의 정보는 사라진다.

어댑티브 인덱스가 팔방미인처럼 보이지만 결국 메모리에 올려진 데이터를 인덱싱하는 것이므로 디스크에 자주접근하는 서비스의 경우에는 크게 도움받지 못할수도 있다. 또한 결국 어댑티브 인덱스도 메모리를 차지하고 있고,
데이터가 변경 및 삭제되면 어댑티브 인덱스의 값도 삭제 및 변경해줘야하기 때문에 오버헤드가 발생할수도 있다.

## MyISAM 스토리지 엔진 아키텍처

MyISAM스토리지 엔진의 성능에 영향을 미치는 요소인 `키캐시`와 `운영체제의 캐시/버퍼`에 대해 살펴보자

### 키캐시

InnoDB의 버퍼풀과 비슷한 역할을 하는 것이 MyISAM의 `키캐시`이다. 하지만 버퍼풀과 달리 키캐시는 **인덱스**를 대상으로 작동하고, 인덱스의 쓰기 작업에 대해서만 부분 버퍼링을 한다.

### 운영체제의 캐시 및 버퍼

MyISAM의 인덱스는 키캐시를 이용해 빠르게 동작하지만, 데이터에 대해서는 어떠한 캐시와 버퍼링이 지원되지 않아 디스크의 접근이 필수적이다. 그래서 MyISAM테이블의 데이터 읽기나 쓰기작업은 항상 운영체제의
디스크 읽기 또는 쓰기 작업으로 요청될수밖에 없다. 대부분의 운영체제는 캐시나 버퍼링이 탑재되어 있어 매번 디스크를 읽지는 않는다.

하지만 운영체제의 캐시나 버퍼링은 InnoDB만큼 전문적이지 않고, 남은 메모리 용량만큼 할당되기 때문에 충분한 메모리를 항상 비워둬야한다는 단점이있다.

### 데이터 파일과 프라이머리 키 구조
InnoDB의 테이블은 PK에 의해 클러스터링되어 저장되지만 MyISAM은 pk에 의한 클러스터링 없이 데이터 파일이 힙공간처럼 활용된다. 즉, MyISAM테이블에 레코드는 PK에 상관없이 Insert순서대로 저장된다.

## MySQL 로그파일
