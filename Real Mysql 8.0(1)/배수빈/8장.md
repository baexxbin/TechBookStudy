# 8장: 인덱스

- mysql에서 사용 가능한 인덱스의 종류 및 특성
    - 왜 중요한가?
        - 물리 수준의 모델링
        - 쿼리 튜닝의 기본

<br>

## 8.1 :  디스크 읽기 방식

> 인덱스를 알아보기 앞서, 짚고갈 개념
- 디스크 읽기 방식
    - 랜덤 I/O
    - 순차 I/O

- 데이터 저장 매체는 컴퓨터에서 가장 느린 부분
    - 데이터베이스 성능튜닝은 어떻게 디스크 I/O를 줄이냐의 관건

<br>

### 8.1.1 : HDD와 SSD

- SSD (Solid State Drive)
    - 개념
        - 기계식 하드 디스크 드라이브를 대체하기 위한 전자식 저장 매체
        - 기존 하드 디스크 드라이브와 같은 인터페이스 지원
    - 특징
        - 기존 하드 디스크 드라이브에서 저장용 플래터 제거
            - 데이터의 빠른 읽고쓰기 가능 (원판의 기계적 회전 X )
        - 대신 플래시 메모리 장착
            - 전원이 공급되지 않아도 데이터 삭제 안됨
            - D-Ram보단 느리지만 기계식 하드디스크 드라이브보단 빠른 속도

<br>


### 8.1.2 : 랜덤I/O와 순차I/O

- 작업 과정 (공통)
    - 하드디스크 드라이브 원판을 돌려, 데이터가 저장된 위치로 디스크 헤더를 이동 시킨 다음 데이터를 읽는 것
    - 랜덤I/O의 이동 > 순차I/O          
    → 디스크의 성능: 디스크 헤더의 위치 이동 없이 많은 데이터를 한번에 기록하는지에 따라 결정
- “쿼리를 튜닝한다”
    - 랜덤I/O 자체를 줄이는 것 (= 쿼리 처리에 꼭 필요한 데이터만 읽는 것)
- 인덱스 레인지 스캔 → 랜덤I/O 사용
- 풀 테이블 스캔 → 순차I/O 사용

<br>

## 8.2 : 인덱스

- 빠른 검색
    - 키-값 형태
    - 정렬
- 자료 구조
    - 인덱스의 구조 (SortedList : 정렬된 상태 유지)
        - 저장 희생, 읽기 속도 높임
    - 데이터 파일의 구조 (ArrayList : 저장된 순서 유지)
- 인덱스의 분류
    - 데이터 저장 방식(알고리즘)
        - B-Tree 인덱스
            - 컬럼 값을 변형하지 않고 원래의 값을 이용해 인덱싱
        - Hash 인덱스
            - 개념
                - 컬럼 값으로 해시값을 계산해 인덱싱하는 알고리즘
            - 특징
                - 매우 빠른 검색 지원
                - 값을 변형하기에 값의 일부, 범위 검색시 사용 불가
                - 주로 메모리 기반 데이터베이스에서 사용
    - 데이터 중복 허용
        - 값이 1개 or 1개 이상 존재하는지
        - 구분
            - Unique Index
                - 1개의 레코드만 찾으면 더이상 찾지 않아도 됨
            - Non Unique Index
    - 인덱스 기능
        - 전문 검색용 인덱스
        - 공간 검색용 인덱스

<br>


## 8.3 : B-Tree 인덱스

> 가장 범용적이며, 가장 먼저 도입된 알고리즘.
B는 Balanced를 의미
> 

- 개념
    - 컬럼의 원래 값을 변형시키지 않고, 인덱스 구조체 내에선 항상 정렬된 상태로 유지
- 구조
    - 루트 노드 : 최상위 1개 존재
    - 브랜치 노드 : 중간 노드
    - 리프 노드 : 하위 자식 노드
        - 항상 실제 데이터 레코드를 찾아가기 위한 주솟값 가짐
    - 정렬
        - (정렬) 인덱스 키값
        - (임의 순서) 데이터 파일 레코드
            - 삭제된 빈곳에 넣음
    - 인덱스와 데이터 파일의 관계
        - MyISAM : 세컨더리 인덱스가 물리적인 주소를 가짐
        - InnoDB : 프라이머리키를 주소처럼 사용 (논리적 주소 가짐)
            - 인덱스를 통해 레코드 읽을 시, 데이터 파일을 바로 찾아가지 못함
- 인덱스 키 추가
    - 리프노드 꽉차면, 리프노드 분리(split)
        - 상위 브랜치 노드까지 처리 범위 넓어짐
        - 상대적으로 쓰기 작업 비용 높음
    - InnoDB는 Insert 똑똑하게 처리
        - 인덱스 키 추가 작업 지연시켜 처리
        - 프라이머리, 유니크 키의 경우 중복체크로 인해 즉시 처리
- 인덱스 키 삭제
    - 삭제할 키 값이 저장된 리프노드를 찾아 삭제 마크
    - 삭제 마킹 역시 디스크 I/O 필요
- 인덱스 키 변경
    1. 키 값 삭제
    2. 다시 새로운 키 추가
- 인덱스 키 검색
    - 트리 탐색: 루트-브랜치-리프거치며 비교 작업
        - select, update, delete 처리시 사용
    - 사용
        - 100% 일치
        - 값 앞부분 일치
        - 부등호 비교 조건
    - 불가능한 경우
        - **인덱스 키 값에 변형이 가해진 후 비교**
            - 함수나 연산 수행 후 결과로 정렬, 검색시 불가
- InnoDB만의 특별한 의미
    - 레코드 잠금, 갭락
        - 검색 수행 → 인덱스 잠금 → 테이블 레코드 잠금
        - 인덱스가 없으면 불필요하게 많은 레코드 잠금
- 인덱스 사용에 영향을 미치는 요소
    - 인덱스 구성 컬럼 크기, 레코드 건수, 유니크 인덱스 키 값 개수
    - 인덱스 키 값 크기
        - 페이지(블록)
            - 디스크 데이터 저장 기본 저장 단위
            - 디스크 모든 읽기 쓰기 작업의 최소 작업 단위
            
            > 인덱스도 결국 페이지 단위로 관리 됨.
            루트, 브랜치, 리프 노드의 구분 기준 또한 페이지 단위
            > 
        - 자식 노드 수
            - 인덱스의 페이지 크기(16kb) 키 값 크기에 따라 결정
            - 인덱스 키 값이 커질 경우
                - 디스크로 부터 읽어야할 횟수 늘어남 → 느려짐
            - 인덱스 키 값 길어짐 → 전체적인 인덱스 크기 커짐
- B-Tree 깊이
    > 중요하나, 직접 제어할 방법 없음
    - 깊이는 mysql에서 값 검색 시, 몇번이나 랜덤하게 디스크를 읽어야하는지와 직결
        - 인덱스 키 값 크기 커질 수록
            - 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수 적어짐
            - B-Tree 깊이가 깊어짐
            - 디스크 읽기 더 많이 필요
- 선택도(기수성)
    - 모든 인덱스 키 값 가운데 유니크한 값의 수
    - 선택도가 높음 → 검색대상 적음 → 빠른 처리
    - 선택도가 낮은게 좋은 경우도 존재
        - 정렬, 그루핑과 같은 작업 시 등
- 읽어야하는 레코드 건수
    - 인덱스로 레코드 읽기는 약 4~5배 정도 비용이 더듦
        - 읽어야할 레코드건수가 전체 20~25% 넘어서면 그냥 테이블 모두 읽고 필터링 처리가 효율적

<br>

### Mysql이 인덱스를 이용하는 방법

- 인덱스 레인지 스캔
    - 개념
        - 검색해야할 인덱스의 범위가 결정됐을때 사용하는 방식
    - 흐름
        1. 인덱스 탐색
            - 레코드 시작 지점: 루트-브랜치-리프 순 비교
        2. 인덱스 스캔
            - 레코드 시작 지점 찾은 후 리프노드의 레코드만 순서대로 읽기
            - 리프 끝에선, 링크를 통해 다음 리프 노드 스캔
        3. 최종 레코드 읽어오기
            - 2번에서 읽어들인 인덱스 키와 레코드 주소 이용해 레코드 페이지 가져옴
            - 커버링 인덱스 : 해당(3번)과정은 필요 없을 경우도 있음
                - 랜덤읽기 줄고, 성능 빨라짐
    - 특징
        - 가장 대표적인 인덱스 접근 방식
        - 3가지 방법 중 가장 빠른 방법
- 인덱스 풀 스캔
    - 개념
        - 인덱스의 처음부터 끝까지 모두 읽는 방식
        - 주로 쿼리가 인덱스에 명시된 컴럼만으로 조건 처리할 수 있을 경우 사용
    - 흐름
        - 인덱스 리프노드의 끝으로 이동
        - 인덱스 리프노드를 연결하는 Linked List를 따라 처음부터 끝까지 스캔
    - 특징
        - 효율: 인덱스 레인지 > 인덱스 풀 스캔 > 테이블 풀 스캔
- 루스 인덱스 스캔
    - 개념
        - 앞선 두 방법과 달리 느슨하게 (듬성듬성) 인덱스를 읽는 것
    - 특징
        - 레인지 스캔과 비슷하나, 중간에 필요하지 않은 값은 무시
            - 보통 Group by, 집합함수 중 Max,Min 최적화시 사용
- 인덱스 스킵 스캔
    - 개념
        - 여러 컬럼으로 인덱스를 생성했을때, 한 컬럼에 대해서만 조건을 걸었을때, 인덱스에 존재하는 모든 값을 추출한 후 그 결과로 조건 처리
    - 단점
        - where조건절에 없는 인덱스의 선행 컬럼의 유니크한 값의 개수가 적어야함
            - 개수가 많다면 시작 지점 검색 작업이 많이 필요 → 쿼리 성능 다운
        - 쿼리가 인덱스에 존재하는 컬럼만으로 처리 가능해야함(커버링 인덱스)
- 다중 컬럼 인덱스
    - 개념
        - 2개이상의 컬럼으로 구성된 인덱스
    - 특징
        - i번째 컬럼은 i-1번째 컬럼에 의존해 정렬 됨
        - 각 컬럼의 순서가 중요
- B-Tree 인덱스의 정렬
    - 오름차순, 내림차순으로 정렬
    - 8.0버전부터 정렬 순서 혼합한 인덱스 사용 가능
- B-Tree 인덱스의 스캔 방향
    - 인덱스 생성 시점엔 정렬 방향이 결정
    - 인덱스 사용 시점엔 읽은 방향에 따라 정렬 방향 결정 가능
- 내림차순 인덱스
    - 오름차순 인덱스
        - 작은 값의 인덱스 키가 B-Tree 왼쪽 정렬 (1→2→3)
    - 내림차순 인덱스
        - 큰 값의 인덱스 키가 B-Tree 왼쪽 정렬 (3→2→1)
    - 정순 스캔 : 인덱스 리프노드 왼쪽 → 오른쪽 스캔
    - 역순 스캔 : 인덱스 리프노드 오른쪽 → 왼쪽 스캔
    - 정순 스캔이 역순 스캔보다 빠름
        - 페이지 잠금이 인덱스 정순 스캔에 적합한 구조임
        - 페이지 내 인덱스 레코드가 단방향으로만 연결된 구조임
- 비교 조건의 종류와 효율성
    - 작업 범위 결정 조건
        - 인덱스가 작업 범위를 결정하는 조건에 영향을 줬을 경우
        - 많을수록 쿼리성능 향상
    - 필터링 조건(체크 조건)
        - 비교 작업의 범위를 줄이기 못하고 단순 거름종이 역할만 한 경우
        - 쿼리 성능에 도움을 주지 못함(오히려 느리게 만듦)
- 인덱스의 가용성
    - B-Tree특징: 왼쪽값에 기준해 오른쪽 값 정렬
        - 다중컬럼 인덱스에서 왼쪽 컬럼값을 모르면 레인지 스캔 불가
        - ex) LIKE에서 %가 앞에 붙으면 효율떨어지는 이유
- 가용성과 효율성 판단
    - mysql에선 Null값도 인덱스에 저장 됨
    - 인덱스를 사용하는 다양한 쿼리패턴에 잘 이용하기

<br>


## 8.4: R-Tree 인덱스

- 공간 인덱스
    - 개념
        - R-Tree 인덱스 알고리즘을 이용해 2차원의 데이터를 인덱싱하고 검색하는 목적의 인덱스
        - MBR정보를 이용해 B-Tree형태로 인덱스를 구축해 R-Tree라는 이름이 붙음
    - 특징
        - 기본적인 내부 매커니즘은 B-Tree와 흡사
        - B-Tree의 인덱스 구성 컬럼값이 1차원이라면, R-Tree 인덱스는 2차원의 공간 개념 값
        - 거리 기반 검색 가능
- Mysql 공간확장
    - 기능
        - 공간 데이터를 저장할 수 있는 데이터 타입
        - 공간 데이터의 검색을 위한 공간 인덱스(R-Tree알고리즘)
    - MBR
        - point, line, polygon, geometry를 감싸는 최소 크기의 사각형

<br>


## 8.5: 전문 검색 인덱스

- 전문 검색 인덱스
    - 개념
        - 문서 전체에 대한 분석과 검색을 위한 인덱싱 알고리즘
    - 사용 조건
        - 퀄이 문장이 전문 검색을 위한 문법 사용
        - 테이블이 전문 검색 대상 컬럼에 대해 전문 인덱스 보유
- 인덱스 알고리즘
    - 사용자가 검색하게될 키워드 분석, 키워드로 인덱스 구축
    - 인덱싱 기법에 따른 알고리즘 분류
        - 어근 분석
            - 불용어 처리: 별 가치 없는 단어 필터링으로 제거
                - 불용어 무시
                    - 불용어 처리가 사용자를 더 헷갈리게 할 수 있기에 무시할 수 있음
                - 사용자 정의 불용어 사용
            - 어근 분석: 검색어로 선정된 단어의 원형 찾기
                - MeCab플러그인 형태로 사용
        - n-gram
            - 개념
                - 전문적인 MeCab대신, 단순히 키워드를 검색하기 위한 인덱싱
            - 방법
                1. 본문을 무소전 몇 글자씩 잘라 인덱싱
                2. 구분된 토근을 B-Tree 인덱스에 저장

<br>

### 8.6 함수기반 인덱스

- 함수기반 인덱스
    - 칼럼값을 변형해 만들어진 값에 대해 인덱스 구축 시 사용
    - 구현 방법
        > 인덱싱 계산 과정 차이뿐, 내부구조는 B-Tree인덱스와 동일
        > 
        - 가상 컬럼 이용 인덱스
            - 테이블에 새로운 컬럼 추가와 같은 효과
            - 실제 테이블 구조가 변경된다는 단점 존재
        - 함수 이용 인덱스
            - 테이블 구조 변경하지 않고, 계산된 결괏값의 검색을 빠르게 만듦
            - 반드시 조건절에 함수 기반 인덱스에 명시된 표현식이 그대로 사용되어야함

<br>

### 8.7 멀티 밸류 인덱스

- 멀티 밸류 인덱스
    - 하나의 데이터 레코드가 여러개의 키 값을 가지는 인덱스 형태
        - join 데이터 타입 지원으로, json의 배열 타입 필드에 저장된 원소들에 대한 인덱스 요건 발생하며 탄생            
            (MongoDB경우 이미 지원하던 인덱스)    
        - 활용 방법
            - MEMBER OF(), JSON_CONTAINS(), JSON_OVERLAPS()
            - 위 함수를 이용해 검색해야 옵티마이저가 인덱스를 활용한 실행계획 수립 가능

<br>

### 8.8 클러스터링 인덱스

> 테이블 데이터를 특정 열 기준으로 정렬해 저장하여 범위 검색과 읽기 성능을 최적화하는 인덱스

- Mysql서버에서의 클러스터링
    - 구현: 테이블의 레코드를 비슷한것들끼리 묶어 저장
        - 주로 비슷한 값들을 동시에 조회하는 경우가 많기때문
- 클러스터링 인덱스
    - 테이블의 프라이머리 키에 대해서만 적용되는 내용
    - 프라이머리 키 값이 비슷한 레코드끼리 묶어 저장하는 것
    - 프라이머리 키 값에 대한 높은 의존
        - 레코드 저장 위치 결정
        - 프라이머리 키 값 변경시 레코드의 물리적 저장위치 변경
    - 특징
        - 프라이머리 키 기반 검색이 빠름
        - 레코드 저장, 프라이머리 키 변경이 상대적으로 느림
- 프라이머리 키가 없는 경우
    - InnoDB스토리지 엔진이 프라이머리 키를 대체할 컬럼 선택
    - 적절한 후보 찾지 못할 경우 내부적으로 `레코드 일렬번호 칼럼` 생성
        - 이는 쿼리 문장에 명시적으로 사용할 수 없으며 아무 없는 숫자값으로 클러스터링됨
- 프라이머리키가 세컨더리 인덱스에 미치는 영향
    - 세컨더리 인덱스
        - 데이터베이스에서 테이블의 기본 정렬 순서와 관계없이 추가적으로 생성된 보조 인덱스
    - InnoDB테이블(클러스터링 테이블)의 모든 세컨더리 인덱스는 프라이머리 키 값을 저장하도록 구현
- 클러스터링 인덱스의 장단점
    - 장점
        - 매우 빠른 처리 성능
        - 테이블의 모든 세컨더리 인덱스는 프라이머리 키를 가지기에 인덱스로만 처리될 수 있는 경우가 많음(커버링 인덱스)
    - 단점
        - 테이블의 모든 세컨더리 인덱스는 프라이머리 키를 가지기에 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스 크기 커짐
        - 세컨더리 인덱스 통한 검색 시 처리 성능 느림
        - 느린 쓰기(Insert, Upate, Delete)

- 클러스터링 테이블 사용 시 주의사항
    - 클러스터링 인덱스 키의 크기
        - 모든 세컨더리 인덱스가 프라이머리키 값을 포함
        - 따라서 이에 비례해서 크기가 커짐
    - 프라이머리 키는 AUTO-INCREMENT 보다 업무적인 컬럼으로 생성
    - 프라이머리 키는 반드시 명시하기
        - 명시하지 않으면, innodb스토리지 엔진이 자동으로 일렬변호 컬럼을 추가하고, 이는 사용자가 접근할 수 없음
    - AUTO-INCREMENT컬럼을 인조 식별자로 사용
        
<br>

### 8.9 유니크 인덱스

- 유니크
    - 제약 조건에 가까움
    - 테이블이나 인덱스에 같은 값이 2개이상 저장될 수 없음
    - 프라이머리 키는 기본적으로 NULL허용X
        - NULL은 특정값이 아니기에 2개이상 저장 가능
- 유니크 인덱스 VS 일반 세컨더리 인덱스
    - 인덱스 구조상은 차이 없음
    - 성능 관점의 차이
        - 인덱스 읽기
            - 레코드를 읽어야하는 수의 차이만 존재할 뿐, 레코드 건수가 같다면 성능상 차이는 미미
        - 인덱스 쓰기
            - 유니크 인덱스의 경우 중복값 체크 과정이 추가됨
            - 중복값 체크 시 `읽기잠금`, 쓰기 시 `쓰기잠금` 사용 → 빈번한 데드락
            - 중복체크로 인한 작업 버퍼링 불가              
            ⇒ **일반 세컨더리 인덱스보다 느린 변경 작업**

- 유니크 인덱스 주의사항
    - Mysql의 유니크 인덱스는 일반 인덱스와 같은 역할을 수행
        - 따라서 둘을 중복해서 생성할 필요 없음
    - 같은 컬럼에 프라이머리 키와 유니크 인덱스 동일 생성 또한 불필요한 중복
    - 유일성이 꼭 보장되어야하는 컬럼에 대해 유니크 인덱스 생성
    - 꼭 필요하지 않다면 유니크하지 않은 세컨덜 인덱스 고려

<br>

### 8.10 외래키

- Mysql에서 외래키는 InnoDB스토리지 엔진에서만 생성 가능
- 외래키 제약이 설정되면 자동으로 연관되는 테이블의 컬럼에 인덱스까지 생성
- 외래키가 제거되지 않은 상태에선 자동으로 생성된 인덱스 삭제 불가
- 특징
    - 테이블의 변경(쓰기 잠금) 발생시에만 잠금 경합(잠금 대기) 발생
        - 자식테이블의 외래키 컬럼의 변경은 부모 테이블의 확인이 필요
    - 외래키와 연관되지 않은 컬럼의 변경은 최대한 잠금 경합(잠금 대기)를 발생시키지 않음
        - 자식테이블의 외래키가 아닌 컬럼의 변경은, 외래키로 인한 잠금확장이 발생하지 않음

> 부모 테이블: 기준 테이블, 자식 테이블: 참조 테이블