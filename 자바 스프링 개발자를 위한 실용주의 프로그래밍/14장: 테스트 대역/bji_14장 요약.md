### 14장 테스트 대역

- 테스트 대역이란, 영화에 나오는 스턴트맨(대역)처럼 실제 객체를 대신하는 객체를 의미함.

| 유형  | 설명                                                     |
| :---- | :------------------------------------------------------- |
| Dummy | 아무런 기능이 없음.                                      |
| Stub  | 특정한 상황에 대해 미리 정해진 결과를 반환함.            |
| Fake  | 자체적인 로직이 있음.                                    |
| Mock  | 아무런 동작을 하지 않지만 어떤 행동이 호출됐는지 기록함. |
| Spy   | 실제 객체를 대신하면서 호출된 행동을 기록함.             |

#### Dummy

- 아무런 동작도 수행하지 않는 객체.
- 아래와 같이 SomethingFilter를 구현해서 테스트 한다고 가정함.
  - 테스트 목표는 giveMe attribute가 text인 경우 응답의 Content-Type을 text/plain으로 변경하는 것.
  - 하지만 filterChain의 역할은 아무것도 없는데 그럼에도 filterChain은 넣어줘야 함.
  - 이럴 경우 filterChain을 **Dummy로 대체**할 수 있음.

```java filename="" copy showLineNumbers {24-28}
public class SomethingFilter extends GenericFilterBean {
  @Override
  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {
    // text를 요청하는 request라면 응답의 Content-Type을 text/plain으로 변경
    if (request.getAttribute("giveMe").equals("text")) {
      response.setContentType("text/plain");
    }

    // 책임 연쇄 패턴에 따라 다음 필터를 실행하기 위해 필터 체인의 doFilter를 호출
    chain.doFilter(request, response);
  }
}

@Test
public void 요청에_text로_달라는_요청이_있으면_응답의_콘텐츠_타입은_text_plain이어야_함() {
  // given
  ServletRequest request = new MockHttpServletRequest();
  request.setAttribute("giveMe", "text");
  ServletResponse response = new MockHttpServletResponse();

  // when
  SomethingFilter filter = new SomethingFilter();
  filter.doFilter(request, response,
    new FilterChain(
      @Override
      public void doFilter(ServletRequest request, ServletResponse response) {
        // do nothing
      })
    );

  // then
  assertThat(response.getContentType()).isEqualTo("text/plain");
}
```

- 위와 같이 Dummy로 생성된 FilterChain은 아무런 동작을 하지 않지만 테스트 실행 결과에는 영향이 없음.

#### Stub

- **Stub**은 '부본', '짧은 부분'이라는 뜻이 있음.
- 원본과 비슷하게 만들어 참고로 보관하는 서류를 뜻하는 말.
- 응답을 최대한 비슷하게 만들어 참고로 사용하는 객체.

```java filename="" copy showLineNumbers
@RequiredArgsConstructor
public class UserService {
  private final UserRepository userRepository;
  public User register(UserCreateDto userCreateDto) {
    if(userRepository.findByEmail(userCreate.getEmail()).isPresent()) {
      throw new DuplicatedException("이미 존재하는 이메일입니다.");
    }
    ...
  }
}
```

- 위와 같은 코드를 테스트한다고 가정할 때, 아래와 같이 Stub을 사용할 수 있음.

```java filename="" copy showLineNumbers
class StubExistUserRepository implements UserRepository {
  @Override
  public Optional<User> findByEmail(String email) {
    return Optional.of(User.builder()
      .id(1L)
      .email(email)
      .nickname("nickname")
      .build());
  }
}

class StubEmptyUserRepository implements UserRepository {
  @Override
  public Optional<User> findByEmail(String email) {
    return Optional.empty();
  }
}
```

- 그리고 위 Stub을 Injection 해서 테스트를 진행할 수 있음.

#### Fake

- 자체적인 로직을 갖고 있는 객체.
- 예를 들면 위에서는 `UserRepository`의 특정한 입력에 대한 특정한 반환을 했다면 **Fake**은 UserRepository의 로직을 직접 구현한 객체를 의미함.

```java filename="" copy showLineNumbers
public class FakeUserRepository implements UserRepository {
  private final long autoGeneratedId = 0L;
  private final List<User> data = new ArrayList<>();

  @Override
  public Optional<User> findByEmail(String email) {
    return data.stream()
      .filter(user -> user.getEmail().equals(email))
      .findFirst();
  }

  @Override
  public User save(User user) {
    if(user.getId() == null || user.getId() == 0) {
      // create 동작
    } else {
      // update 동작
    }
    return user;
  }
}
```

#### Mock

- 아무런 기능도 안하지만 주로 메서드 호출이 발생했는지 여부를 검증.

```java filename="" copy showLineNumbers
public class MockVerificationEmailSender implements EmailSender {
  private boolean called = false;

  @Override
  public void send(Email email) {
    called = true;
  }

  public boolean isCalled() {
    return called;
  }
}
```

#### Spy

- 어떤 메서드가 호출되고 이벤트가 몇 번 발생했는지 확인할 때 사용.

```java filename="" copy showLineNumbers
public class SpyUserRepository extends UserRepository{
  private int findByEmailCall = 0;
  private int saveCall = 0;

  @Override
  public Optional<User> findByEmail(String email) {
    findByEmailCall++;
    return super.findByEmail(email);
  }

  @Override
  public User save(User user) {
    saveCall++;
    return super.save(user);
  }
}
```

- 또는 UserRepository를 implements하고 JpaUserRepository를 주입받아서 구현할 수도 있음.

```java filename="" copy showLineNumbers
public class SpyUserRepository implements UserRepository {
  private final UserRepository userRepository;
  private int findByEmailCall = 0;
  private int saveCall = 0;

  public SpyUserRepository(UserRepository userRepository) {
    this.userRepository = userRepository;
  }

  @Override
  public Optional<User> findByEmail(String email) {
    findByEmailCall++;
    return userRepository.findByEmail(email);
  }

  @Override
  public User save(User user) {
    saveCall++;
    return userRepository.save(user);
  }
}
```

#### 상태기반 검증 & 행위기반 검증

- 상태기반 검증
  - 테스트 대상의 상태가 어떻게 변화하는지 검증하는 방법.
- 행위기반 검증
  - 테스트의 검증 동작에 메서드 호출 여부를 보게하는 방법.
- 상태기반 검증으로 하는 편이 좋음. 👉 테스트를 책임 단위로 볼 수 있기 때문.
- 상태기반 테스트는 '어떻게 목표를 달성해왔는가?'에 집중함.

#### 결론

- 테스트 대역을 적절히 사용하면 중형으로 보였던 테스트를 소형으로 변경할 수 있음.
- 기술을 숙달하기 전에 기반 지식은 반드시 숙지해야 함.
  - 자바가 갑자기 멸망하면 js나 python의 테스팅 프레임웤을 다시 공부해야함.
  - 하지만 테스트 대역을 알면 어떤 언어에서도 응용이 가능함.
- 추상화와 의존성 역전을 잘 해놔야 대역을 활용하기 좀 더 편해짐.
