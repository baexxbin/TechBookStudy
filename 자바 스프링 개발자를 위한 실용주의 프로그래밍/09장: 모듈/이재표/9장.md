## 9장 [모듈]

### 모듈성

**모듈이란**

일반적으로 다음과 같은 답변

1. 모듈으 프로그램의 기본 구성 요소이다.
    1. 너무 넓은 의미이다.
2. 특수한 목적을 가지고 만들어지는 라이브러리이다.
    1. 라이브러리를 사용하지않는다면 모듈이 없는것인가?

모듈은 라이브러리와 프로그램의 구성 요소 사이에 위치하는 개념이다.

<img src="https://github.com/user-attachments/assets/7d0f591b-aff6-4fa9-983a-b4c9253c279a" width=350>

모듈의 크기는 받아들이는 사람마다 다르기 때문에 명확한 기준이 필요하다. 저자의 기준은 다음과 같다.
> 소프트웨어 관점에서 모듈이란 독립성과 은닉성을 만족하며 연관된 코드들의 묶음이다.
>
> 독립성: 모듈은 독립적이어야 한다.
>
>은닉성: 모듈의 사용자는 모듈의 내부구현을 몰라도 된다. 공개된 인터페이스를 이용해 모듈과 통신한다.



독립성과 은닉성에 관해 설명하기 전, 그렇다면 모듈시스템이란 무엇일까요?
> 모듈 시스템이란 연관된 코드 묶음이 '모듈성'을 갖출수 있게 도와주는 시스템적인 해결책입니다. 모듈성을 지원하기 위해 모듈시스템은 다음과 같은 기능을 필수적으로 지원해야 합니다.
>
> 1. 의존성 관리: 모듈을 사용하기 위해 어떤 의존성이 필요한지 명시할 수 있어야한다.
> 2. 캡슐화 관리: 모듈은 불필요한 구현을 외부로 드러내지 않아야한다.


모듈 시스템이 이 같은 기능을 제공해야하는 이유는 각각 독립성과 은닉성에 대응해서 생각할 수 있습니다. 무슨 의미냐면 모듈이 독립성을 보장하기 위해 모듈 시스템은 모듈차원의 의존성 관리를 할 수 있어야한다는 것이다.
그리고 모듈이 은닉성을 보장하기 위해 모듈 시스템은 모듈 차원의 캡슐화 관리를 할 수 있어야한다

그렇다면 자바의 패키지 시스템은 모듈 시스템이라 볼수 있을까?
정답은 아니다. 자바의 패키지 시스템은 패키지 수준의 의존성 관리와 캡슐화 관리 기능을 지원하지 않기 때문이다.

자바의 패키지 시스템은 연관성이 높은 코드를 묶는 수단에 불과하다.

대신 자바에는 더 확실한 모듈 시스템이 존재한다. 바로 module-info.java라고 하는 모듈 디스크립터이다.

```java
module myproject.main {
    requires org.apache.httpcomponents.httpclient;
    exports com.myorg.myproject.model;
}
```

위의 코드를 보면 모듈 디스크립터에 myproject.main이라는 이름으로 모듈의 이름을 정의하고, requires를 이용해 외부 의존성을 관리하는 것을 확인할 수 있다. 또한 exports로 외부로 노출할 모듈
내 인터페이스 패키지를 관리하는 것도 확인할 수 있다.

myproject.main이라는 모듈에는 수많은 패키지가 있지만, 특정 패키지만 노출하여 모듈 수준의 캡슐화 관리하는 목표를 달성하고 있는것이다.

#### 독립성

모듈은 독립적이어야한다. 라는 의미는 모듈이 다른 모듈이나 컴포넌트에 강하게 의존하지 않고 각 모듈을 개별적으로 수정하거나 교체할수 있어야한다는 뜻이다. 그리고 모듈이 독립적이어야 하는 이유는 유지보수를 용이하게
하고, 확장성을 높이고, 코드의 재사용성을 높이기 위함입니다.

따라서 독립적인 모듈은 개발 과정에서의 효율성을 높이고 시스템 전체의 안정성을 유지하는 데 도움이 됩니다. 또한 코드를 테스트하기 쉽게 만들수 있어 전체 시스템의 품질을 높이는데 기여합니다.

모듈은 도립적이어야합니다. 이 말은 곧 다음과 같이 풀이할 수 있습니다.

- 모듈을 사용하기 전, 필요한 의존성을 알 수 있어야합ㄴ다.
- 모듈의 의존성이 모두 준비된다면 모둘을 사용하는데 문제가 없어야한다.

이같은 해석은 '모듈이 독립적이려면 의존성을 관리할 수 있어야한다'라는 명제로 이어집닏.

그렇다면 모듈의 독립성은 왜 '의존성을 관리해야한다'로 이어질까요?
다음예시를 살펴보겠습니다.

```java
package com.myproject.account;

public class Account {

}
```

```java
package com.myproject.post;

import com.myproject.account.Account;

public class Post {
    Account writer;
}
```

서로 다른 패키지에 위치한 코드입니다. 두 클래스의 패키지를 비교했을때 어떤 패키지가 더 독립적일까요?

어떤 패키지가 더 독립적인지 알기위해 각 패키지의 의존관계를 생각해보자!. Post클래스는 게시글 작성자를 표현하기 위해 Account클래스를 사용합니다. 따라서 post패키지는 account패키지에 의존합니다.

한편 account패키지는 다른 패키지나 클래스에 의존하지 않습니다. 따라서 하나라도 더 외부패키지에 의존하는 post패키지가 독립성이 떨어진다고 평가할 수 있습니다.

그렇다고 post패키지가 독립적이지 않다는것은 아니다. 상대적으로 독립성이 떨어지는 것이다.

따라서 '어떤 시스템이 독집적이어야 한다.'는 외부 시스템과 완전히 격리돼야 한다는 말이 아니다. 단지 강한 의존이 생기는 것을 피하라는 의미이다.

'독립적이어야한다'는 말은 다음과 같이 이해하는 것이 바람직하다.
- 최대한 내부에서 해결해라
- 외부에는 강하게 의존하지 마라
- 외부시스템을 사용하면 외부 시스템의 사용을 명시하라

외부 시스템의 사용을 명시하라는 말이 중요하다. 모듈의 독립성을 보장하려면 외부시스템에 대한 의존을 드러내고 관리해야한다는 의미이다.
독립적인 모듈은 모듈에 사용된 하위 의존성이 무엇인지 알수있다.! 이것이 모듈 시스템에 '의존성 관리 기능'이 반드시 필요한 이유이다.


### 은닉성
모듈은 은닉성을 추구해야합니다. 은닉성을 추구해야한다는 말은 클래스가 은닉성을 추구하는 것처럼 모듈 수준의 캡슐화가 가능해야한다는 말이다. 즉, 우리는 모듈을 외부에 공유하더라도 공개된 인터페이스 이외에 불필요한 정보를 숨길수 있길 원합니다.

하지만 왜 은닉성을 추구해야할까? 단순하게 '작업이 편하기 위해'입니다.

**하이럼 법칙**
- API를 사용하는 사용자가 충분히 많다면 개발자의 설계의도는 더이상 중요하지 않다. 왜냐하면 사용자는 API를 온갖방법으로 사용할 것이기때문이다. 

해당 법칙을 보면 결과적으로 API에는 초기의도와는 다른 새로운 책임이 추가 할당된다. 하지만 이렇게 생긴 암묵적인 책임과 부담은 API개발자의 몫입니다. 공식적인 책임이 아니어도 API에 할당된 암묵적인 책임을 기대하고 사용하는 사용자가 많기때문에 함부로 건드리지 못합니다.

예로들어 B라이브러리의 임시 클래스를 두고 업데이트를 통해 임시 클래스를 삭제했다면 해당 클래스를 사용하고 있던 사용자들이 불만하게된다. 하지만 해당 클래스는 버그를 야기해서 삭제해야만 했다. 은닉성을 지키지 않는다면 이러한 상황을 맞을수있기때문에 지켜야한다.

